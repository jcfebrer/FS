//*******************************************************************
// File name: $ cxcore_h.cs $
// Author:		$ Heiko Kießling, (c) iib-chemnitz.de $
// Email:			hki@hrz.tu-chemnitz.de
// 
// License:		There is no explicit license attached. The code is
//						provided 'as is'. Feel free to use the code how you like 
//						but without any warranty.
//						If you include the code in your own projects and/or
//						redistribute pls. include this header.
//
// History:		Rev. 1.0 (beta), hki - initial revision
// ToDo:			Documentation
//*******************************************************************
// Code generated by cvDocParser V1.0
//*******************************************************************


using System;
using System.Collections.Generic;
using System.Text;

namespace openCV
{
	public partial class cvlib
	{
		public static CvScalar CV_RGB(int r, int g, int b)
		{
			return new CvScalar(b, g, r, 0);
		}

		public const int CV_FILLED = -1;
		public const int CV_AA = 16;
		public const int CV_AUTOSTEP = 0x7fffffff;


/* Decrements CvMat data reference counter and deallocates the data if
   it reaches 0 */
//public static  void  cvDecRefData( CvArr* arr )
//{
//    if( CV_IS_MAT( arr ))
//    {
//        CvMat* mat = (CvMat*)arr;
//        mat->data.ptr = NULL;
//        if( mat->refcount != NULL && --*mat->refcount == 0 )
//            cvFree( &mat->refcount );
//        mat->refcount = NULL;
//    }
//    else if( CV_IS_MATND( arr ))
//    {
//        CvMatND* mat = (CvMatND*)arr;
//        mat->data.ptr = NULL;
//        if( mat->refcount != NULL && --*mat->refcount == 0 )
//            cvFree( &mat->refcount );
//        mat->refcount = NULL;
//    }
//}

///* Increments CvMat data reference counter */
//public static  int  cvIncRefData( CvArr* arr )
//{
//    int refcount = 0;
//    if( CV_IS_MAT( arr ))
//    {
//        CvMat* mat = (CvMat*)arr;
//        if( mat->refcount != NULL )
//            refcount = ++*mat->refcount;
//    }
//    else if( CV_IS_MATND( arr ))
//    {
//        CvMatND* mat = (CvMatND*)arr;
//        if( mat->refcount != NULL )
//            refcount = ++*mat->refcount;
//    }
//    return refcount;
//}



//public static  CvMat*  cvGetRow( const CvArr* arr, CvMat* submat, int row )
//{
//    return cvGetRows( arr, submat, row, row + 1, 1 );
//}


//public static  CvMat*  cvGetCol( const CvArr* arr, CvMat* submat, int col )
//{
//    return cvGetCols( arr, submat, col, col + 1 );
//}




/* Releases CvMatND */
//public static  void  cvReleaseMatND( CvMatND** mat )
//{
//    cvReleaseMat( (CvMat**)mat );
//}


// returns next sparse array node (or NULL if there is no more nodes)
//public static CvSparseNode* cvGetNextSparseNode( CvSparseMatIterator* mat_iterator )
//{
//    if( mat_iterator->node->next )
//        return mat_iterator->node = mat_iterator->node->next;
//    else
//    {
//        int idx;
//        for( idx = ++mat_iterator->curidx; idx < mat_iterator->mat->hashsize; idx++ )
//        {
//            CvSparseNode* node = (CvSparseNode*)mat_iterator->mat->hashtable[idx];
//            if( node )
//            {
//                mat_iterator->curidx = idx;
//                return mat_iterator->node = node;
//            }
//        }
//        return NULL;
//    }
//}

/**************** matrix iterator: used for n-ary operations on dense arrays *********/

		public const int CV_MAX_ARR = 10;

//public struct CvNArrayIterator
//{
//    public int count; /* number of arrays */
//    public int dims; /* number of dimensions to iterate */
//    public CvSize size; /* maximal common linear size: { width = size, height = 1 } */
//    public uchar* ptr[CV_MAX_ARR]; /* pointers to the array slices */
//    public int stack[CV_MAX_DIM]; /* for internal use */
//    [MarshalAS
//    public CvMatND* hdr[CV_MAX_ARR]; /* pointers to the headers of the
//                                 matrices that are processed */
//}

		public const int CV_NO_DEPTH_CHECK = 1;
		public const int CV_NO_CN_CHECK = 2;
		public const int CV_NO_SIZE_CHECK = 4;


		//public const int cvReshapeND( = arr, header, new_cn, new_dims, new_sizes );
		//  cvReshapeMatND( (arr), sizeof(*(header)), (header),         \
		//                  (new_cn), (new_dims), (new_sizes))

		//public const int cvConvert( = src, dst ) cvConvertScale( (src), (dst), 1, 0 );



/* dst(mask) = src(mask) - value = src(mask) + (-value) */
//public static  void  cvSubS( const CvArr* src, CvScalar value, CvArr* dst,
//                         const CvArr* mask CV_DEFAULT(NULL))
//{
//    cvAddS( src, cvScalar( -value.val[0], -value.val[1], -value.val[2], -value.val[3]),
//            dst, mask );
//}


		public const int CV_CMP_EQ = 0;
		public const int CV_CMP_GT = 1;
		public const int CV_CMP_GE = 2;
		public const int CV_CMP_LT = 3;
		public const int CV_CMP_LE = 4;
		public const int CV_CMP_NE = 5;



		public const int CV_CHECK_RANGE = 1;
		public const int CV_CHECK_QUIET = 2;

		public const int CV_RAND_UNI = 0;
		public const int CV_RAND_NORMAL = 1;


		//public const int cvMatMulAdd( = src1, src2, src3, dst ) cvGEMM( (src1), (src2), 1 , (src3), 1 , (dst), 0 );
		//public const int cvMatMul( = src1, src2, dst ) cvMatMulAdd( (src1), (src2), NULL, (dst));

		public const int CV_GEMM_A_T = 1;
		public const int CV_GEMM_B_T = 2;
		public const int CV_GEMM_C_T = 4;


		public const int CV_SVD_MODIFY_A = 1;
		public const int CV_SVD_U_T = 2;
		public const int CV_SVD_V_T = 4;

		public const int CV_LU = 0;
		public const int CV_SVD = 1;
		public const int CV_SVD_SYM = 2;

/* Calculates covariation matrix for a set of vectors */
/* transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...] */
		public const int CV_COVAR_SCRAMBLED = 0;

/* [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...]) */
		public const int CV_COVAR_NORMAL = 1;

/* do not calc average (i.e. mean vector) - use the input vector instead
   (useful for calculating covariance matrix by parts) */
		public const int CV_COVAR_USE_AVG = 2;

/* scale the covariance matrix coefficients by number of the vectors */
		public const int CV_COVAR_SCALE = 4;

/* all the input vectors are stored in a single matrix, as its rows */
		public const int CV_COVAR_ROWS = 8;

/* all the input vectors are stored in a single matrix, as its columns */
		public const int CV_COVAR_COLS = 16;


		public const int CV_PCA_DATA_AS_ROW = 0;
		public const int CV_PCA_DATA_AS_COL = 1;
		public const int CV_PCA_USE_AVG = 2;

/* types of array norm */
		public const int CV_C = 1;
		public const int CV_L1 = 2;
		public const int CV_L2 = 4;
		public const int CV_NORM_MASK = 7;
		public const int CV_RELATIVE = 8;
		public const int CV_DIFF = 16;
		public const int CV_MINMAX = 32;

		public const int CV_DIFF_C = (CV_DIFF | CV_C);
		public const int CV_DIFF_L1 = (CV_DIFF | CV_L1);
		public const int CV_DIFF_L2 = (CV_DIFF | CV_L2);
		public const int CV_RELATIVE_C = (CV_RELATIVE | CV_C);
		public const int CV_RELATIVE_L1 = (CV_RELATIVE | CV_L1);
		public const int CV_RELATIVE_L2 = (CV_RELATIVE | CV_L2);


		public const int CV_REDUCE_SUM = 0;
		public const int CV_REDUCE_AVG = 1;
		public const int CV_REDUCE_MAX = 2;
		public const int CV_REDUCE_MIN = 3;


		public const int CV_DXT_FORWARD = 0;
		public const int CV_DXT_INVERSE = 1;
		public const int CV_DXT_SCALE = 2 /* divide result by size of array */;
		public const int CV_DXT_INV_SCALE = (CV_DXT_INVERSE | CV_DXT_SCALE);
		public const int CV_DXT_INVERSE_SCALE = CV_DXT_INV_SCALE;
		public const int CV_DXT_ROWS = 4 /* transform each row individually */;
		public const int CV_DXT_MUL_CONJ = 8 /* conjugate the second argument of cvMulSpectrums */;


		public const int CV_FRONT = 1;
		public const int CV_BACK = 0;

//public static CvSeq* cvCloneSeq( const CvSeq* seq, CvMemStorage* storage CV_DEFAULT(NULL))
//{
//    return cvSeqSlice( seq, CV_WHOLE_SEQ, storage, 1 );
//}


/* a < b ? -1 : a > b ? 1 : 0 */
//typedef int (CV_CDECL* CvCmpFunc)(const void* a, const void* b, void* userdata );


/* Fast variant of cvSetAdd */
//public static  CvSetElem* cvSetNew( CvSet* set_header )
//{
//    CvSetElem* elem = set_header->free_elems;
//    if( elem )
//    {
//        set_header->free_elems = elem->next_free;
//        elem->flags = elem->flags & CV_SET_ELEM_IDX_MASK;
//        set_header->active_count++;
//    }
//    else
//        cvSetAdd( set_header, NULL, (CvSetElem**)&elem );
//    return elem;
//}

/* Removes set element given its pointer */
//public static  void cvSetRemoveByPtr( CvSet* set_header, void* elem )
//{
//    CvSetElem* _elem = (CvSetElem*)elem;
//    assert( _elem->flags >= 0 /*&& (elem->flags & CV_SET_ELEM_IDX_MASK) < set_header->total*/ );
//    _elem->next_free = set_header->free_elems;
//    _elem->flags = (_elem->flags & CV_SET_ELEM_IDX_MASK) | CV_SET_ELEM_FREE_FLAG;
//    set_header->free_elems = _elem;
//    set_header->active_count--;
//}


/* Returns a set element by index. If the element doesn't belong to the set,
   NULL is returned */
//public static CvSetElem* cvGetSetElem( const CvSet* set_header, int index )
//{
//    CvSetElem* elem = (CvSetElem*)cvGetSeqElem( (CvSeq*)set_header, index );
//    return elem && CV_IS_SET_ELEM( elem ) ? elem : 0;
//}



///* Retrieves graph vertex by given index */
//    public const int cvGetGraphVtx( = graph, idx ) (CvGraphVtx*)cvGetSetElem((CvSet*)(graph), (idx));

///* Retrieves index of a graph vertex given its pointer */
//    public const int cvGraphVtxIdx( = graph, vtx ) ((vtx)- flags CV_SET_ELEM_IDX_MASK);

///* Retrieves index of a graph edge given its pointer */
//    public const int cvGraphEdgeIdx( = graph, edge ) ((edge)- flags CV_SET_ELEM_IDX_MASK);

//    public const int cvGraphGetVtxCount( = graph ) ((graph)- active_count);
//    public const int cvGraphGetEdgeCount( = graph ) ((graph)- edges- active_count);

		public const int CV_GRAPH_VERTEX = 1;
		public const int CV_GRAPH_TREE_EDGE = 2;
		public const int CV_GRAPH_BACK_EDGE = 4;
		public const int CV_GRAPH_FORWARD_EDGE = 8;
		public const int CV_GRAPH_CROSS_EDGE = 16;
		public const int CV_GRAPH_ANY_EDGE = 30;
		public const int CV_GRAPH_NEW_TREE = 32;
		public const int CV_GRAPH_BACKTRACKING = 64;
		public const int CV_GRAPH_OVER = -1;

		public const int CV_GRAPH_ALL_ITEMS = -1;

/* flags for graph vertices and edges */
		public const int CV_GRAPH_ITEM_VISITED_FLAG = (1 | 30);
		//public const int CV_IS_GRAPH_VERTEX_VISITED(vtx) =     (((CvGraphVtx*)(vtx))->flags & CV_GRAPH_ITEM_VISITED_FLAG)
		//public const int CV_IS_GRAPH_EDGE_VISITED(edge) =     (((CvGraphEdge*)(edge))->flags & CV_GRAPH_ITEM_VISITED_FLAG)
		public const int CV_GRAPH_SEARCH_TREE_NODE_FLAG = (1 << 29);
		public const int CV_GRAPH_FORWARD_EDGE_FLAG = (1 << 28);




//public static  void  cvEllipseBox( CvArr* img, CvBox2D box, CvScalar color,
//                               int thickness CV_DEFAULT(1),
//                               int line_type CV_DEFAULT(8), int shift CV_DEFAULT(0) )
//{
//    CvSize axes;
//    axes.width = cvRound(box.size.height*0.5);
//    axes.height = cvRound(box.size.width*0.5);
    
//    cvEllipse( img, cvPointFrom32f( box.center ), axes, box.angle,
//               0, 360, color, thickness, line_type, shift );
//}


		/* Moves iterator to the next line point */
    public static void CV_NEXT_LINE_POINT ( ref CvLineIterator line_iterator )
		{
			unsafe
			{
				int mask = line_iterator.err < 0 ? -1 : 0;
				(line_iterator).err += line_iterator.minus_delta +
				(line_iterator.plus_delta & mask);
				(line_iterator).pt = (IntPtr)(line_iterator.pt.ToInt32() + line_iterator.minus_step + (line_iterator.plus_step & mask));
			}
		}

		public static CvPoint CV_LINE_POINT(ref CvLineIterator line_iterator, ref IplImage img)
		{
			unsafe
			{
				CvPoint pt = new CvPoint();
				int ofs = line_iterator.pt.ToInt32() - img.imageData.ToInt32();

				pt.y = ofs / img.widthStep;
				pt.x = (ofs - pt.y * img.widthStep) / (img.nChannels * ((img.depth & 255) >> 3));

				return pt;
			}
		}


/* basic font types */
		public const int CV_FONT_HERSHEY_SIMPLEX = 0;
		public const int CV_FONT_HERSHEY_PLAIN = 1;
		public const int CV_FONT_HERSHEY_DUPLEX = 2;
		public const int CV_FONT_HERSHEY_COMPLEX = 3;
		public const int CV_FONT_HERSHEY_TRIPLEX = 4;
		public const int CV_FONT_HERSHEY_COMPLEX_SMALL = 5;
		public const int CV_FONT_HERSHEY_SCRIPT_SIMPLEX = 6;
		public const int CV_FONT_HERSHEY_SCRIPT_COMPLEX = 7;

/* font flags */
		public const int CV_FONT_ITALIC = 16;

		public const int CV_FONT_VECTOR0 = CV_FONT_HERSHEY_SIMPLEX;



//public static CvFont cvFont( double scale, int thickness CV_DEFAULT(1) )
//{
//    CvFont font;
//    cvInitFont( &font, CV_FONT_HERSHEY_PLAIN, scale, scale, 0, thickness, CV_AA );
//    return font;
//}


		public const int CV_ErrModeLeaf = 0 /* Print error and exit program */;
		public const int CV_ErrModeParent = 1 /* Print error and continue */;
		public const int CV_ErrModeSilent = 2 /* Don t print and continue */;


//typedef int (CV_CDECL *CvErrorCallback)( int status, const char* func_name,
//                    const char* err_msg, const char* file_name, int line, void* userdata );

	}
}
