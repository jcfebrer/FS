//*******************************************************************
// File name: $ CxTypes_h.cs $
// Author:		$ Heiko Kieﬂling, (c) iib-chemnitz.de $
// Email:			hki@hrz.tu-chemnitz.de
// 
// License:		There is no explicit license attached. The code is
//						provided 'as is'. Feel free to use the code how you like 
//						but without any warranty.
//						If you include the code in your own projects and/or
//						redistribute pls. include this header.
//
// History:		Rev. 1.0 (beta), hki - initial revision
// ToDo:			Documentation
//*******************************************************************
// Code generated by cvDocParser V1.0
//*******************************************************************


using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Drawing;

namespace openCV
{
	/// <summary>
	/// 2D point with integer coordinates
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvPoint
	{
		/// <summary>
		/// x-coordinate
		/// </summary>
		public int x;

		/// <summary>
		/// y-coordinate
		/// </summary>
		public int y;

		/// <summary>
		/// constructor
		/// </summary>
		/// <param name="x">x-coordinate</param>
		/// <param name="y">y-coordinate</param>
		public CvPoint(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
	}

	/// <summary>
	/// 2D point with floating-point coordinates
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvPoint2D32f
	{
		/// <summary>
		/// x-coordinate of the point
		/// </summary>
		public float x;

		/// <summary>
		/// y-coordinate of the point
		/// </summary>
		public float y;

		/// <summary>
		/// constructor
		/// </summary>
		/// <param name="x">x-coordinate</param>
		/// <param name="y">y-coordinate</param>
		public CvPoint2D32f(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
	}

	/// <summary>
	/// D point with floating-point coordinates
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvPoint3D32f
	{
		/// <summary>
		/// x-coordinate of the point
		/// </summary>
		public float x;

		/// <summary>
		/// y-coordinate of the point
		/// </summary>
		public float y;

		/// <summary>
		/// y-coordinate of the point
		/// </summary>
		public float z;

		/// <summary>
		/// Contructor
		/// </summary>
		/// <param name="x">x-coordinate</param>
		/// <param name="y">y-coordinate</param>
		/// <param name="z">z-coordinate</param>
		public CvPoint3D32f(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	/// <summary>
	/// 2D point with double precision floating-point coordinates
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvPoint2D64f
	{
		/// <summary>
		/// x-coordinate
		/// </summary>
		public double x;
		
		/// <summary>
		/// y-coordinate
		/// </summary>
		public double y;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="x">x-coordinate</param>
		/// <param name="y">y-coordinate</param>
		public CvPoint2D64f(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
	}

	/// <summary>
	/// 3D point with double precision floating-point coordinates
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvPoint3D64f
	{
		/// <summary>
		/// x-coordinate
		/// </summary>
		public double x;
		
		/// <summary>
		/// y-coordinate
		/// </summary>
		public double y;
		
		/// <summary>
		/// z-coordinate
		/// </summary>
		public double z;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="x">x-coordinate</param>
		/// <param name="y">y-coordinate</param>
		/// <param name="z">z-coordinate</param>
		public CvPoint3D64f(double x, double y, double z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	/// <summary>
	/// pixel accurate size of a rectangle
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSize
	{
		/// <summary>
		/// width of the rectangle
		/// </summary>
		public int width;
		
		/// <summary>
		/// height of the rectangle
		/// </summary>
		public int height;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="width">width of the rectangle</param>
		/// <param name="height">height of the rectangle</param>
		public CvSize(int width, int height)
		{
			this.width = width;
			this.height = height;
		}
	}

	/// <summary>
	/// sub-pixel accurate size of a rectangle
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSize2D32f
	{
		/// <summary>
		/// width of the rectangle
		/// </summary>
		public float width;
		
		/// <summary>
		/// height of the rectangle
		/// </summary>
		public float height;
		
		/// <summary>
		/// 
		/// </summary>
		/// <param name="width">width of the rectangle</param>
		/// <param name="height">height of the rectangle</param>
		public CvSize2D32f(float width, float height)
		{
			this.width = width;
			this.height = height;
		}
	}

	/// <summary>
	/// offset and size of a rectangle
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvRect
	{
		/// <summary>
		/// x-coordinate of the left-most rectangle corner[s]
		/// </summary>
		public int x;
		
		/// <summary>
		/// y-coordinate of the top-most or bottom-most rectangle corner[s]
		/// </summary>
		public int y;
		
		/// <summary>
		/// width of the rectangle
		/// </summary>
		public int width;
		
		/// <summary>
		/// height of the rectangle
		/// </summary>
		public int height;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="x">x-coordinate of the left-most rectangle corner[s]</param>
		/// <param name="y">y-coordinate of the top-most or bottom-most rectangle corner[s]</param>
		/// <param name="width">width of the rectangle</param>
		/// <param name="height">height of the rectangle</param>
		public CvRect(int x, int y, int width, int height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}
	}

	/// <summary>
	/// A container for 1-,2-,3- or 4-tuples of numbers
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvScalar
	{
		/// <summary>
		/// value 1
		/// </summary>
		public double val1;

		/// <summary>
		/// value 2
		/// </summary>
		public double val2;

		/// <summary>
		/// value 3
		/// </summary>
		public double val3;

		/// <summary>
		/// value 4
		/// </summary>
		public double val4;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="v1">value 1</param>
		/// <param name="v2">value 2</param>
		/// <param name="v3">value 3</param>
		/// <param name="v4">value 4</param>
		public CvScalar(double v1, double v2, double v3, double v4)
		{
			val1 = v1; val2 = v2; val3 = v3; val4 = v4;
		}
	}

	/// <summary>
	/// Termination criteria for iterative algorithms
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvTermCriteria
	{
		/// <summary>
		/// may be combination of
		/// CV_TERMCRIT_ITER 
		/// CV_TERMCRIT_EPS
		/// </summary>
		public int type;  
		
		/// <summary>
		/// maximum number of iterations
		/// </summary>
		public int max_iter;

		/// <summary>
		/// accuracy to achieve
		/// </summary>
		public double epsilon;

		/// <summary>
		/// Constructor
		/// check termination criteria and transform it so that type=CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,
		/// and both max_iter and epsilon are valid
		/// </summary>
		/// <param name="type"> may be combination of
		/// CV_TERMCRIT_ITER 
		/// CV_TERMCRIT_EPS</param>
		/// <param name="max_iter">maximum number of iterations</param>
		/// <param name="epsilon">accuracy to achieve</param>
		public CvTermCriteria(int type, int max_iter, double epsilon)
		{
			this.type = type;
			this.max_iter = max_iter;
			this.epsilon = epsilon;
		}
	}

	/// <summary>
	/// Multi-channel matrix
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct CvMat
	{
		/// <summary>
		/// CvMat signature (CV_MAT_MAGIC_VAL), element type and flags
		/// </summary>
		[FieldOffset(0)] 
		public int type;
		
		/// <summary>
		/// full row length in bytes
		/// </summary>
		[FieldOffset(4)] 
		public int step;
		
		/// <summary>
		/// for internal use only
		/// </summary>
		[FieldOffset(8)]
		public IntPtr refcount;

		/// <summary>
		/// for internal use only
		/// </summary>
		[FieldOffset(12)]
		public int hdr_refcount;
		
		/// <summary>
		/// underlaying data pointer
		/// </summary>
		[FieldOffset(16)]
		public IntPtr data;
		
		/// <summary>
		/// number of rows
		/// </summary>
		[FieldOffset(20)]
		public int rows;
		
		/// <summary>
		/// number of rows
		/// </summary>
		[FieldOffset(20)] 
		public int height;
		
		/// <summary>
		/// number of columns
		/// </summary>
		[FieldOffset(24)] 
		public int cols;
		
		/// <summary>
		/// number of columns
		/// </summary>
		[FieldOffset(24)] 
		public int width;
		
		/// <summary>
		/// this pointer
		/// </summary>
		[FieldOffset(28)] 
		public IntPtr ptr;
	}

	/// <summary>
	/// pairs (number of elements, distance between elements in bytes) for every dimension
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct Dim
	{
		/// <summary>
		/// size
		/// </summary>
		public int size;

		/// <summary>
		/// step
		/// </summary>
		public int step;
	}

	/// <summary>
	/// Multi-dimensional dense multi-channel array
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvMatND
	{
		/// <summary>
		/// CvMatND signature (CV_MATND_MAGIC_VAL), element type and flags
		/// </summary>
		public int type;

		/// <summary>
		/// number of array dimensions
		/// </summary>
		public int dims;

		/// <summary>
		/// for internal use only
		/// </summary>
		public IntPtr refcount;

		/// <summary>
		/// for internal use only
		/// </summary>
		public int hdr_refcount;

		/// <summary>
		/// underlaying data pointer
		/// </summary>
		public IntPtr data;

		/// <summary>
		/// pairs (number of elements, distance between elements in bytes) for every dimension 
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		public Dim[] dim;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Multi-dimensional sparse multi-channel array
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSparseMat
	{
		/// <summary>
		/// CvSparseMat signature (CV_SPARSE_MAT_MAGIC_VAL), element type and flags
		/// </summary>
		public int type;
		
		/// <summary>
		/// number of dimensions
		/// </summary>
		public int dims;
		
		/// <summary>
		/// reference counter - not used
		/// </summary>
		public IntPtr refcount;
		
		/// <summary>
		/// hdr reference counter - not used
		/// </summary>
		public int hdr_refcount;
		
		/// <summary>
		/// a pool of hashtable nodes
		/// </summary>
		public IntPtr heap;
		
		/// <summary>
		/// hashtable: each entry has a list of nodes
		/// having the same "hashvalue modulo hashsize"
		/// </summary>
		public IntPtr hashtable;
		
		/// <summary>
		/// total number of sparse array nodes
		/// </summary>
		public int hashsize;
		
		/// <summary>
		/// value offset in bytes for the array nodes
		/// </summary>
		public int valoffset;
		
		/// <summary>
		/// index offset in bytes for the array nodes
		/// </summary>
		public int idxoffset;
		
		/// <summary>
		/// arr of dimension sizes
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		public int[] size;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Ipl Image structure
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
	public struct IplImage
	{
		/// <summary>
		/// sizeof(IplImage) 
		/// </summary>
		public int nSize;
		
		/// <summary>
		/// version (=0)
		/// </summary>
		public int ID;
		
		/// <summary>
		/// Most of OpenCV functions support 1,2,3 or 4 channels 
		/// </summary>
		public int nChannels;
		
		/// <summary>
		/// ignored by OpenCV 
		/// </summary>
		public int alphaChannel;
		
		/// <summary>
		/// pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U, IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported 
		/// </summary>
		public int depth;
		
		/// <summary>
		/// ignored by OpenCV 
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public byte[] colorModel;
		
		/// <summary>
		/// ditto
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public byte[] channelSeq;
		
		/// <summary>
		/// 0 - interleaved color channels, 1 - separate color channels.
		/// cvCreateImage can only create interleaved images 
		/// </summary>
		public int dataOrder;
		
		/// <summary>
		/// 0 - top-left origin,
		/// 1 - bottom-left origin (Windows bitmaps style)
		/// </summary>
		public int origin;
		
		/// <summary>
		/// Alignment of image rows (4 or 8).
		/// OpenCV ignores it and uses widthStep instead 
		/// </summary>
		public int align;
		
		/// <summary>
		/// image width in pixels 
		/// </summary>
		public int width;
		
		/// <summary>
		/// image height in pixels 
		/// </summary>
		public int height;
		
		/// <summary>
		/// image ROI. when it is not NULL, this specifies image region to process 
		/// </summary>
		public IntPtr roi;
		
		/// <summary>
		/// must be NULL in OpenCV 
		/// </summary>
		public IntPtr maskROI;
		
		/// <summary>
		/// ditto
		/// </summary>
		public IntPtr imageId;
		
		/// <summary>
		/// ditto 
		/// </summary>
		public IntPtr tileInfo;
		
		/// <summary>
		/// image data size in bytes
		/// (=image->height*image->widthStep in case of interleaved data)
		/// </summary>
		public int imageSize;
		
		/// <summary>
		/// pointer to aligned image data 
		/// </summary>
		public IntPtr imageData;
		
		/// <summary>
		/// size of aligned image row in bytes 
		/// </summary>
		public int widthStep;
		
		/// <summary>
		/// border completion mode, ignored by OpenCV 
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public int[] BorderMode;
		
		/// <summary>
		/// ditto
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public int[] BorderConst;
		
		/// <summary>
		///  pointer to a very origin of image data (not necessarily aligned) - it is needed for correct image deallocation 
		/// </summary>
		public IntPtr imageDataOrigin;
		
		/// <summary>
		/// Pointer to the unmanaged memory
		/// </summary>
		public IntPtr ptr;
		
		/// <summary>
		/// Converts this to Bitmap
		/// </summary>
		/// <param name="img"></param>
		/// <returns></returns>
		public static explicit operator Bitmap(IplImage img)
		{
			return cvlib.ToBitmap(img, false);
		}
	}

	/// <summary>
	/// The structure CvMemBlock represents a single 
	/// lock of memory storage. Actual data of the memory 
	/// blocks follows the header, that is, the i-th byte 
	/// of the memory block can be retrieved with the 
	/// expression ((char*)(mem_block_ptr+1))[i]. However, 
	/// normally there is no need to access the storage structure 
	/// fields directly.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvMemBlock
	{
		/// <summary>
		/// Previus
		/// </summary>
		public IntPtr prev;
		
		/// <summary>
		/// Next
		/// </summary>
		public IntPtr next;
	}

	/// <summary>
	/// Growing memory storage
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvMemStorage
	{
		/// <summary>
		/// internal signature
		/// </summary>
		public int signature;
		
		/// <summary>
		/// first allocated block
		/// </summary>
		public IntPtr bottom;
		
		/// <summary>
		/// current memory block - top of the stack
		/// </summary>
		public IntPtr top;
		
		/// <summary>
		/// borrows new blocks from
		/// </summary>
		public IntPtr parent;
		
		/// <summary>
		/// block size
		/// </summary>
		public int block_size;
		
		/// <summary>
		/// free space in the current block
		/// </summary>
		public int free_space;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// The structure described below stores the position 
	/// of the stack top that can be saved via 
	/// cvSaveMemStoragePos and restored via cvRestoreMemStoragePos.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvMemStoragePos
	{
		/// <summary>
		/// Top
		/// </summary>
		public IntPtr top;
		
		/// <summary>
		/// Free space
		/// </summary>
		public int free_space;
	}

	/// <summary>
	/// Allocates text string in the storage
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet= CharSet.Ansi)]
	public struct CvString
	{
		/// <summary>
		/// Length of the string (w/o \'0')
		/// </summary>
		public int len;
		
		/// <summary>
		/// this ptr
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Growable sequence of elements
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSeq
	{
		/// <summary>
		/// micsellaneous flags
		/// </summary>
		public int flags;
		
		/// <summary>
		/// size of sequence header
		/// </summary>
		public int header_size;
		
		/// <summary>
		/// previous sequence
		/// </summary>
		public IntPtr h_prev;
		
		/// <summary>
		/// next sequence
		/// </summary>
		public IntPtr h_next;
		
		/// <summary>
		/// 2nd previous sequence
		/// </summary>
		public IntPtr v_prev;
		
		/// <summary>
		/// 2nd next sequence
		/// </summary>
		public IntPtr v_next;
		
		/// <summary>
		/// total number of elements
		/// </summary>
		public int total;
		
		/// <summary>
		/// size of sequence element in bytes
		/// </summary>
		public int elem_size;
		
		/// <summary>
		/// maximal bound of the last block
		/// </summary>
		public IntPtr block_max;
		
		/// <summary>
		/// current write pointer
		/// [this name was changed, because the this pointer]
		/// </summary>
		public IntPtr pt;
		
		/// <summary>
		/// how many elements allocated when the seq grows
		/// </summary>
		public int delta_elems;
		
		/// <summary>
		/// where the seq is stored
		/// </summary>
		public IntPtr storage;
		
		/// <summary>
		/// free blocks list
		/// </summary>
		public IntPtr free_blocks;
		
		/// <summary>
		/// pointer to the first sequence block
		/// </summary>
		public IntPtr first;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Continuous sequence block
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSeqBlock
	{
		/// <summary>
		/// previous sequence block
		/// </summary>
		public IntPtr prev;
		
		/// <summary>
		/// next sequence block
		/// </summary>
		public IntPtr next;
		
		/// <summary>
		/// index of the first element in the block +
		/// sequence->first->start_index
		/// </summary>
		public int start_index;
	  
		/// <summary>
		/// number of elements in the block
		/// </summary>
		public int count;
		
		/// <summary>
		/// pointer to the first element of the block
		/// </summary>
		public IntPtr data;

		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// A sequence slice
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSlice
	{
		/// <summary>
		/// Start Index
		/// </summary>
		public int start_index;

		/// <summary>
		/// End Index
		/// </summary>
		public int end_index;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="start_index">Start Index</param>
		/// <param name="end_index">End Index</param>
		public CvSlice(int start_index, int end_index)
		{
			this.start_index = start_index;
			this.end_index = end_index;
		}
	}

	/// <summary>
	/// Internal
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSetElem
	{
		/// <summary>
		/// flags
		/// </summary>
		public int flags;
		
		/// <summary>
		/// next_free
		/// </summary>
		public IntPtr next_free;
		
		/// <summary>
		/// ptr
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Collection of nodes
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvSet
	{
		/// <summary>
		/// micsellaneous flags
		/// </summary>
		public int flags;
		
		/// <summary>
		/// size of sequence header
		/// </summary>
		public int header_size;
		
		/// <summary>
		/// previous sequence
		/// </summary>
		public IntPtr h_prev;
		
		/// <summary>
		/// next sequence
		/// </summary>
		public IntPtr h_next;
		
		/// <summary>
		/// 2nd previous sequence
		/// </summary>
		public IntPtr v_prev;
		
		/// <summary>
		/// 2nd next sequence
		/// </summary>
		public IntPtr v_next;
		
		/// <summary>
		/// total number of elements
		/// </summary>
		public int total;
		
		/// <summary>
		/// size of sequence element in bytes
		/// </summary>
		public int elem_size;
		
		/// <summary>
		/// maximal bound of the last block
		/// </summary>
		public IntPtr block_max;
		
		/// <summary>
		/// current write pointer
		/// </summary>
		public IntPtr pt;
		
		/// <summary>
		/// how many elements allocated when the seq grows
		/// </summary>
		public int delta_elems;
		
		/// <summary>
		/// where the seq is stored
		/// </summary>
		public IntPtr storage;
		
		/// <summary>
		/// free blocks list
		/// </summary>
		public IntPtr free_blocks;
		
		/// <summary>
		/// pointer to the first sequence block
		/// </summary>
		public IntPtr first;
		
		/// <summary>
		/// free elements
		/// </summary>
		public IntPtr free_elems;
		
		/// <summary>
		/// active count
		/// </summary>
		public int active_count;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// A graph vertex
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvGraphVtx
	{
		/// <summary>
		/// vertex flags
		/// </summary>
		public int flags;

		/// <summary>
		/// the first incident edge
		/// </summary>
		public IntPtr first;
		
		/// <summary>
		/// Internal data pointer
		/// </summary>
		public IntPtr pt;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Graph Edge
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvGraphEdge
	{
		/// <summary>
		/// edge flags
		/// </summary>
		public int flags;

		/// <summary>
		/// edge weight
		/// </summary>
		public float weight;

		/// <summary>
		/// the next edges in the incidence lists for staring (0) and ending (1) vertices
		/// </summary>
		public IntPtr next;
		
		/// <summary>
		/// the starting (0) and ending (1) vertices
		/// </summary>
		public IntPtr vtx;

		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Oriented or unoriented weigted graph
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvGraph
	{
		/// <summary>
		/// micsellaneous flags
		/// </summary>
		public int flags;

		/// <summary>
		/// size of sequence header
		/// </summary>
		public int header_size;
		
		/// <summary>
		/// previous sequence
		/// </summary>
		public IntPtr h_prev;
		
		
		/// <summary>
		/// next sequence
		/// </summary>
		public IntPtr h_next;
		
		/// <summary>
		/// 2nd previous sequence
		/// </summary>
		public IntPtr v_prev;


		/// <summary>
		/// 2nd next sequence
		/// </summary>
		public IntPtr v_next;
		
		
		/// <summary>
		/// total number of elements
		/// </summary>
		public int total;
		
		/// <summary>
		/// size of sequence element in bytes
		/// </summary>
		public int elem_size;


		/// <summary>
		/// maximal bound of the last block
		/// </summary>
		public IntPtr block_max;
		
		/// <summary>
		/// current write pointer
		/// </summary>
		public IntPtr pt;
		
		/// <summary>
		/// how many elements allocated when the seq grows
		/// </summary>
		public int delta_elems;
		
		
		/// <summary>
		/// where the seq is stored
		/// </summary>
		public IntPtr storage;
			
		/// <summary>
		/// free blocks list
		/// </summary>
		public IntPtr free_blocks;
		
		/// <summary>
		/// pointer to the first sequence block
		/// </summary>
		public IntPtr first;
		
		/// <summary>
		/// internal use
		/// </summary>
		public IntPtr free_elems;
		
		/// <summary>
		/// internal use
		/// </summary>
		public int active_count;
		
		/// <summary>
		/// Set of edges
		/// </summary>
		public IntPtr edges;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Graph traversal state
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvGraphScanner
	{
		/// <summary>
		/// current graph vertex (or current edge origin)
		/// </summary>
		public IntPtr vtx;
		
		/// <summary>
		/// current graph edge destination vertex
		/// </summary>
		public IntPtr dst;
		
		/// <summary>
		/// current edge
		/// </summary>
		public IntPtr edge;
		
		/// <summary>
		/// the graph
		/// </summary>
		public IntPtr graph;
		
		/// <summary>
		/// the graph vertex stack
		/// </summary>
		public IntPtr stack;
		
		/// <summary>
		/// the lower bound of certainly visited vertices
		/// </summary>
		public int index;
		
		/// <summary>
		/// event mask
		/// </summary>
		public int mask;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Opens existing or creates new file storage
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvTreeNodeIterator
	{
		/// <summary>
		/// node
		/// </summary>
		public IntPtr node;
		
		/// <summary>
		/// level
		/// </summary>
		public int level;
		
		/// <summary>
		/// max_level
		/// </summary>
		public int max_level;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// File Storage
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvFileStorage
	{
		/// <summary>
		/// flags
		/// </summary>
		public int flags;
		
		/// <summary>
		/// is_xml
		/// </summary>
    public int is_xml;
		
		/// <summary>
		/// write_mode
		/// </summary>
    public int write_mode;
		
		/// <summary>
		/// is_first
		/// </summary>
    public int is_first;
		
		/// <summary>
		/// memstorage
		/// </summary>
    public IntPtr memstorage;
		
		/// <summary>
		/// dststorage
		/// </summary>
    public IntPtr dststorage;
		
		/// <summary>
		/// strstorage
		/// </summary>
    public IntPtr strstorage;
		
		/// <summary>
		/// str_hash
		/// </summary>
    public IntPtr str_hash;
		
		/// <summary>
		/// roots
		/// </summary>
    public IntPtr roots;
		
		/// <summary>
		/// write_stack
		/// </summary>
    public IntPtr write_stack;
		
		/// <summary>
		/// struct_indent
		/// </summary>
    public int struct_indent;
		
		/// <summary>
		/// struct_flags
		/// </summary>
    public int struct_flags;
		
		/// <summary>
		/// struct_tag
		/// </summary>
    public CvString struct_tag;
		
		/// <summary>
		/// space
		/// </summary>
    public int space;
		
		/// <summary>
		/// 
		/// </summary>
    public IntPtr filename;
		
		/// <summary>
		/// 
		/// </summary>
    public IntPtr file;
		
		/// <summary>
		/// 
		/// </summary>
    public IntPtr buffer;
		
		/// <summary>
		/// 
		/// </summary>
    public IntPtr buffer_start;
		
		/// <summary>
		/// 
		/// </summary>
    public IntPtr buffer_end;
		
		/// <summary>
		/// 
		/// </summary>
    public int wrap_margin;
		
		/// <summary>
		/// 
		/// </summary>
    public int lineno;
		
		/// <summary>
		/// 
		/// </summary>
    public int dummy_eof;
		
		/// <summary>
		/// 
		/// </summary>
    public IntPtr errmsg;
		
		/// <summary>
		/// 
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst=128)]
    public char[] errmsgbuf;

		/// <summary>
		/// 
		/// </summary>
		public IntPtr start_write_struct;
		
		/// <summary>
		/// 
		/// </summary>
		public IntPtr end_write_struct;
		
		/// <summary>
		/// 
		/// </summary>
		public IntPtr write_int;
		
		/// <summary>
		/// 
		/// </summary>
		public IntPtr write_real;
		
		/// <summary>
		/// 
		/// </summary>
		public IntPtr write_string;
		
		/// <summary>
		/// 
		/// </summary>
		public IntPtr write_comment;
		
		/// <summary>
		/// 
		/// </summary>
		public IntPtr start_next_stream;

		/// <summary>
		/// 
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// all the keys (names) of elements in the readed file storage
	/// are stored in the hash to speed up the lookup operations
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvStringHashNode
	{
		/// <summary>
		/// hashval
		/// </summary>
		public uint hashval;
		
		/// <summary>
		/// str
		/// </summary>
		public CvString str;
	
		/// <summary>
		/// next
		/// </summary>
		public IntPtr next;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// basic element of the file storage - scalar or collection
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CvFileNode
	{
		/// <summary>
		/// Tag info
		/// </summary>
		public int tag;
		
		/// <summary>
		/// type information (only for user-defined object, for others it is 0)
		/// </summary>
		public IntPtr info;
		
		/// <summary>
		/// Data pointer:
		/// {
		///    double f; /* scalar floating-point number */
		///    int i;    /* scalar integer number */
		///    CvString str; /* text string */
		///    CvSeq* seq; /* sequence (ordered collection of file nodes) */
		///    CvFileNodeHash* map; /* map (collection of named file nodes) */
		/// } data;
		/// </summary>
		public IntPtr data;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// List of attributes
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]
	public struct CvAttrList
	{
		/// <summary>
		/// NULL-terminated array of (attribute_name,attribute_value) pairs 
		/// </summary>
		public IntPtr attr;
		
		/// <summary>
		/// pointer to next chunk of the attributes list
		/// </summary>
		public IntPtr next;
		
		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	/// <summary>
	/// Type information
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]
	public struct CvTypeInfo
	{
		/// <summary>
		/// not used
		/// </summary>
		public int flags;

		/// <summary>
		/// sizeof(CvTypeInfo)
		/// </summary>
		public int header_size;

		/// <summary>
		/// previous registered type in the list
		/// </summary>
		public IntPtr prev;

		/// <summary>
		/// not documented
		/// </summary>
		public IntPtr next;

		/// <summary>
		/// next registered type in the list
		/// </summary>
		public IntPtr type_name;

		/// <summary>
		/// not documentd
		/// </summary>
		public IntPtr pt;

		/// <summary>
		/// checks if the passed object belongs to the type
		/// </summary>
		public IntPtr is_instance;

		/// <summary>
		/// releases object (memory etc.)
		/// </summary>
		public IntPtr release;

		/// <summary>
		/// reads object from file storage
		/// </summary>
		public IntPtr read;

		/// <summary>
		/// reads object from file storage
		/// </summary>
		public IntPtr write;

		/// <summary>
		/// creates a copy of the object
		/// </summary>
		public IntPtr clone;

		/// <summary>
		/// this pointer
		/// </summary>
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]
	public struct CvPluginFuncInfo
	{
	  public IntPtr func_addr;
	  public IntPtr default_func_addr;
	  public string func_names;
		public int search_modules;
		public int loaded_from;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]
	public struct CvModuleInfo
	{
	  public IntPtr next;
	  public StringBuilder name;
	  public StringBuilder version;
	  public IntPtr func_tab;
		public IntPtr ptr;
	}
	
	//[StructLayout(LayoutKind.Explicit)]
	//public struct Cv32suf
	//{
	//  [FieldOffset(0)]
	//  public int i;
	//  [FieldOffset(0)]
	//  public uint u;
	//  [FieldOffset(0)]
	//  public float f;
	//}

	//[StructLayout(LayoutKind.Explicit)]
	//public struct Cv64suf
	//{
	//  [FieldOffset(0)]
	//  public long i;
	//  [FieldOffset(0)]
	//  public ulong u;
	//  [FieldOffset(0)]
	//  public double f;
	//}

	/// <summary>
	/// Internal used Structure
	/// </summary>
	public struct IplTileInfo { };


	[StructLayout(LayoutKind.Sequential)]
	public struct IplROI
	{
		/* 0 - no COI (all channels are selected), 
		 * 1 - 0th channel is selected ...
		 */
		public int coi;
		public int xOffset;
		public int yOffset;
		public int width;
		public int height;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct IplConvKernel
	{
		public int nCols;
		public int nRows;
		public int anchorX;
		public int anchorY;
		public IntPtr values; /* int[] */
		public int nShiftR;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct IplConvKernelFP
	{
		public int nCols;
		public int nRows;
		public int anchorX;
		public int anchorY;
		public IntPtr values; //float*
		public IntPtr ptr;
	}


	[StructLayout(LayoutKind.Sequential)]
	public struct DataType
	{
		public IntPtr dt;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvSparseNode
	{
		public uint hashval;
		public IntPtr next;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvSparseMatIterator
	{
		public IntPtr mat;
		public IntPtr node;
		public int curidx;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvHistogram
	{
		public int type;
		public IntPtr bins;
		public IntPtr thresh; /* for uniform histograms */
		public IntPtr thresh2; /* for non-uniform histograms */
		public CvMatND mat; /* embedded matrix header for array histograms */
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvBox2D
	{
		public CvPoint2D32f center;  /* center of the box */
		public CvSize2D32f size;    /* box width and length */
		public float angle;          /* angle between the horizontal axis
	                           and the first side (i.e. length) in degrees */
		public IntPtr ptr; 
	}


	/* Line iterator state */
	[StructLayout(LayoutKind.Sequential)]
	public struct CvLineIterator
	{
		/* pointer to the current point */
		public IntPtr pt;

		/* Bresenham algorithm state */
		public int err;
		public int plus_delta;
		public int minus_delta;
		public int plus_step;
		public int minus_step;
		public IntPtr ptr;
	}


	[StructLayout(LayoutKind.Sequential)]
	public struct CvGraphVtx2D
	{
		public int flags;
		public IntPtr first;
		public IntPtr pt;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvChain
	{
		public int flags;						/* micsellaneous flags */
		public int header_size;			/* size of sequence header */
		public IntPtr h_prev;				/* previous sequence */
		public IntPtr h_next;				/* next sequence */
		public IntPtr v_prev;				/* 2nd previous sequence */
		public IntPtr v_next;				/* 2nd next sequence */
		public int total;						/* total number of elements */
		public int elem_size;				/* size of sequence element in bytes */
		public IntPtr block_max;    /* maximal bound of the last block */
		public IntPtr pt;						/* current write pointer */
		public int delta_elems;			/* how many elements allocated when the seq grows */
		public IntPtr storage;			/* where the seq is stored */
		public IntPtr free_blocks;	/* free blocks list */
		public IntPtr first;				/* pointer to the first sequence block */
		public CvPoint origin;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvContour
	{
		public int flags;						/* micsellaneous flags */
		public int header_size;			/* size of sequence header */
		public IntPtr h_prev;				/* previous sequence */
		public IntPtr h_next;				/* next sequence */
		public IntPtr v_prev;				/* 2nd previous sequence */
		public IntPtr v_next;				/* 2nd next sequence */
		public int total;						/* total number of elements */
		public int elem_size;				/* size of sequence element in bytes */
		public IntPtr block_max;		/* maximal bound of the last block */
		public IntPtr pt;						/* current write pointer */
		public int delta_elems;			/* how many elements allocated when the seq grows */
		public IntPtr storage;			/* where the seq is stored */
		public IntPtr free_blocks;  /* free blocks list */
		public IntPtr first;				/* pointer to the first sequence block */
		public CvRect rect;
		public int color;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst=3)]
		public int[] reserved;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvPoint2DSeq
	{
		public int flags;						/* micsellaneous flags */
		public int header_size;			/* size of sequence header */
		public IntPtr h_prev;				/* previous sequence */
		public IntPtr h_next;				/* next sequence */
		public IntPtr v_prev;				/* 2nd previous sequence */
		public IntPtr v_next;				/* 2nd next sequence */
		public int total;						/* total number of elements */
		public int elem_size;				/* size of sequence element in bytes */
		public IntPtr block_max;		/* maximal bound of the last block */
		public IntPtr pt;						/* current write pointer */
		public int delta_elems;			/* how many elements allocated when the seq grows */
		public IntPtr storage;			/* where the seq is stored */
		public IntPtr free_blocks;  /* free blocks list */
		public IntPtr first;				/* pointer to the first sequence block */
		public CvRect rect;
		public int color;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public int[] reserved;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvSeqWriter
	{
	  public int header_size;                                      
	  public IntPtr	seq;        /* the sequence written */            
	  public IntPtr	block;      /* current block */                   
	  public IntPtr pt;        /* pointer to free space */           
	  public IntPtr block_min;  /* pointer to the beginning of block*/
	  public IntPtr block_max;  /* pointer to the end of block */
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvSeqReader
	{
	  public int header_size;                                       
	  public IntPtr seq;        /* sequence, beign read */
	  public IntPtr block;      /* current block */
	  public IntPtr pt;        /* pointer to element be read next */
	  public IntPtr block_min;  /* pointer to the beginning of block */
	  public IntPtr block_max;  /* pointer to the end of block */
	  public int delta_index;		/* = seq->first->start_index   */
	  public IntPtr prev_elem;  /* pointer to previous element */
		public IntPtr ptr;
	}

	public partial class cvlib
	{
		public const uint IPL_DEPTH_SIGN = 0x80000000;
		public const uint IPL_DEPTH_1U = 1;
		public const uint IPL_DEPTH_8U = 8;
		public const uint IPL_DEPTH_16U = 16;
		public const uint IPL_DEPTH_32F = 32;
		public const uint IPL_DEPTH_8S = (IPL_DEPTH_SIGN | 8);
		public const uint IPL_DEPTH_16S = (IPL_DEPTH_SIGN | 16);
		public const uint IPL_DEPTH_32S = (IPL_DEPTH_SIGN | 32);
		public const int IPL_DATA_ORDER_PIXEL = 0;
		public const int IPL_DATA_ORDER_PLANE = 1;
		public const int IPL_ORIGIN_TL = 0;
		public const int IPL_ORIGIN_BL = 1;
		public const int IPL_ALIGN_4BYTES = 4;
		public const int IPL_ALIGN_8BYTES = 8;
		public const int IPL_ALIGN_16BYTES = 16;
		public const int IPL_ALIGN_32BYTES = 32;
		public const int IPL_ALIGN_DWORD = IPL_ALIGN_4BYTES;
		public const int IPL_ALIGN_QWORD = IPL_ALIGN_8BYTES;
		public const int IPL_BORDER_CONSTANT = 0;
		public const int IPL_BORDER_REPLICATE = 1;
		public const int IPL_BORDER_REFLECT = 2;
		public const int IPL_BORDER_WRAP = 3;
		public const int IPL_IMAGE_HEADER = 1;
		public const int IPL_IMAGE_DATA = 2;
		public const int IPL_IMAGE_ROI = 4;
		public const int IPL_BORDER_REFLECT_101 = 4;
		// ToDo
		//public const int IPL_IMAGE_MAGIC_VAL = ((int)sizeof(IplImage));
		public const string CV_TYPE_NAME_IMAGE = "opencv-image";
		/* for storing double-precisio floating point data in IplImage's */
		public const int IPL_DEPTH_64F = 64;

		/****************************************************************************************
		*                       Multi-dimensional dense array (CvMatND)                          *
		****************************************************************************************/

		public const int CV_MATND_MAGIC_VAL = 0x42430000;
		public const string CV_TYPE_NAME_MATND = "opencv-nd-matrix";

		public const int CV_MAX_DIM = 32;
		public const int CV_MAX_DIM_HEAP = (1 << 16);



		public static bool CV_IS_MATND_HDR(CvMatND mat)
		{
			return (((mat.type & CV_MAGIC_MASK) == CV_MATND_MAGIC_VAL));
		}

		public static bool CV_IS_MATND(CvMatND mat)
		{
			return (CV_IS_MATND_HDR(mat) && (mat.data != IntPtr.Zero));
		}

		/****************************************************************************************
		*                      Multi-dimensional sparse array (CvSparseMat)                      *
		****************************************************************************************/

		public const int CV_SPARSE_MAT_MAGIC_VAL = 0x42440000;
		public const string CV_TYPE_NAME_SPARSE_MAT = "opencv-sparse-matrix";


		public static bool CV_IS_SPARSE_MAT_HDR(CvSparseMat mat)
		{
			return ((mat.type & CV_MAGIC_MASK) == CV_SPARSE_MAT_MAGIC_VAL);
		}

		public static bool CV_IS_SPARSE_MAT(CvSparseMat mat)
		{
			return CV_IS_SPARSE_MAT_HDR(mat);
		}

		/**************** iteration through a sparse array *****************/

		//#define CV_NODE_VAL(mat,node)   ((void*)((uchar*)(node) + (mat)->valoffset))
		//#define CV_NODE_IDX(mat,node)   ((int*)((uchar*)(node) + (mat)->idxoffset))

		/****************************************************************************************
		*                                         Histogram                                      *
		****************************************************************************************/

		public int CvHistType;

		public const int CV_HIST_MAGIC_VAL = 0x42450000;
		public const int CV_HIST_UNIFORM_FLAG = (1 << 10);

		/* indicates whether bin ranges are set already or not */
		public const int CV_HIST_RANGES_FLAG = (1 << 11);

		public const int CV_HIST_ARRAY = 0;
		public const int CV_HIST_SPARSE = 1;
		public const int CV_HIST_TREE = CV_HIST_SPARSE;

		/* should be used as a parameter only,
			 it turns to CV_HIST_UNIFORM_FLAG of hist->type
		 */
		public const int CV_HIST_UNIFORM = 1;

		public static bool CV_IS_HIST(CvHistogram hist)
		{
			return ((hist.type & CV_MAGIC_MASK) == CV_HIST_MAGIC_VAL); //&&
			//hist.bins != null);
		}

		public static bool CV_IS_UNIFORM_HIST(CvHistogram hist)
		{
			return ((hist.type & CV_HIST_UNIFORM_FLAG) != 0);
		}

		//public static bool CV_IS_SPARSE_HIST(CvHistogram hist )
		//{
		//  return CV_IS_SPARSE_MAT(hist.bins);
		//}

		public static bool CV_HIST_HAS_RANGES(CvHistogram hist)
		{
			return ((hist.type & CV_HIST_RANGES_FLAG) != 0);
		}

		/****************************************************************************************
		*                      Other supplementary data type definitions                         *
		****************************************************************************************/

		/*************************************** CvRect *****************************************/

		public static CvRect cvRect(int x, int y, int width, int height)
		{
			CvRect r;

			r.x = x;
			r.y = y;
			r.width = width;
			r.height = height;

			return r;
		}

		public static IplROI cvRectToROI(CvRect rect, int coi)
		{
			IplROI roi = new IplROI();
			roi.xOffset = rect.x;
			roi.yOffset = rect.y;
			roi.width = rect.width;
			roi.height = rect.height;
			roi.coi = coi;

			return roi;
		}


		public static CvRect cvROIToRect(IplROI roi)
		{
			return cvRect(roi.xOffset, roi.yOffset, roi.width, roi.height);
		}

		/*********************************** CvTermCriteria *************************************/

		public const int CV_TERMCRIT_ITER = 1;
		public const int CV_TERMCRIT_NUMBER = CV_TERMCRIT_ITER;
		public const int CV_TERMCRIT_EPS = 2;

		public static CvTermCriteria cvTermCriteria(int type, int max_iter, double epsilon)
		{
			CvTermCriteria t;

			t.type = type;
			t.max_iter = max_iter;
			t.epsilon = epsilon;

			return t;
		}




		/************************************* CvSlice ******************************************/
		public static CvSlice cvSlice(int start, int end)
		{
			CvSlice slice = new CvSlice();
			slice.start_index = start;
			slice.end_index = end;

			return slice;
		}

		public static int CV_WHOLE_SEQ_END_INDEX = 0x3fffffff;
		public static CvSlice CV_WHOLE_SEQ = cvSlice(0, CV_WHOLE_SEQ_END_INDEX);


		/************************************* CvScalar *****************************************/

		public static CvScalar cvScalar(double val1, double val2,
																		 double val3, double val4)
		{
			CvScalar scalar = new CvScalar(val1, val2, val3, val4);
			return scalar;
		}


		public static CvScalar cvRealScalar(double val1)
		{
			CvScalar scalar = new CvScalar(val1,0,0,0);
			return scalar;
		}

		public static CvScalar cvScalarAll(double val0123)
		{
			CvScalar scalar = new CvScalar(val0123, val0123, val0123, val0123);
			return scalar;
		}

		/****************************************************************************************
		*                                   Dynamic Data structures                              *
		****************************************************************************************/

		/******************************** Memory storage ****************************************/

		public const int CV_STORAGE_MAGIC_VAL = 0x42890000;

		public static bool CV_IS_STORAGE(CvMemStorage storage)
		{
			return (((storage.signature & CV_MAGIC_MASK) == CV_STORAGE_MAGIC_VAL));
		}

		/*********************************** Sequence *******************************************/

		public const string CV_TYPE_NAME_SEQ = "opencv-sequence";
		public const string CV_TYPE_NAME_SEQ_TREE = "opencv-sequence-tree";

		/*************************************** Set ********************************************/
		/*
			Set.
			Order is not preserved. There can be gaps between sequence elements.
			After the element has been inserted it stays in the same place all the time.
			The MSB(most-significant or sign bit) of the first field (flags) is 0 iff the element exists.
		*/

		public const int CV_SET_ELEM_IDX_MASK = ((1 << 26) - 1);
		public const int CV_SET_ELEM_FREE_FLAG = (1 << (sizeof(int) * 8 - 1));

		/* Checks whether the element pointed by ptr belongs to a set or not */
		public static bool CV_IS_SET_ELEM(CvSetElem ptr)
		{
			return (ptr.flags >= 0);
		}

		/************************************* Graph ********************************************/

		/*
			Graph is represented as a set of vertices.
			Vertices contain their adjacency lists (more exactly, pointers to first incoming or
			outcoming edge (or 0 if isolated vertex)). Edges are stored in another set.
			There is a single-linked list of incoming/outcoming edges for each vertex.

			Each edge consists of:
				two pointers to the starting and the ending vertices (vtx[0] and vtx[1],
				respectively). Graph may be oriented or not. In the second case, edges between
				vertex i to vertex j are not distingueshed (during the search operations).

				two pointers to next edges for the starting and the ending vertices.
				next[0] points to the next edge in the vtx[0] adjacency list and
				next[1] points to the next edge in the vtx[1] adjacency list.
		*/

		public const string CV_TYPE_NAME_GRAPH = "opencv-graph";

		/*********************************** Chain/Countour *************************************/


		/****************************************************************************************
		*                                    Sequence types                                      *
		****************************************************************************************/

		public const int CV_SEQ_MAGIC_VAL = 0x42990000;

		public static bool CV_IS_SEQ(CvSeq seq)
		{
			return (((seq.flags & CV_MAGIC_MASK) == CV_SEQ_MAGIC_VAL));
		}

		public const int CV_SET_MAGIC_VAL = 0x42980000;
		public static bool CV_IS_SET(CvSet set)
		{
			return (((set.flags & CV_MAGIC_MASK) == CV_SET_MAGIC_VAL));
		}
		public static bool CV_IS_SET(CvSeq set)
		{
			return (((set.flags & CV_MAGIC_MASK) == CV_SET_MAGIC_VAL));
		}
		public const int CV_SEQ_ELTYPE_BITS = 9;
		public const int CV_SEQ_ELTYPE_MASK = ((1 << CV_SEQ_ELTYPE_BITS) - 1);

		public static int CV_SEQ_ELTYPE_POINT = CV_32SC2;  /* (x,y) */
		public static int CV_SEQ_ELTYPE_CODE = CV_8UC1;   /* freeman code: 0..7 */
		public const int CV_SEQ_ELTYPE_GENERIC = 0;
		public const int CV_SEQ_ELTYPE_PTR = CV_USRTYPE1;
		public const int CV_SEQ_ELTYPE_PPOINT = CV_SEQ_ELTYPE_PTR;  /* &(x,y) */
		public static int CV_SEQ_ELTYPE_INDEX = CV_32SC1;  /* #(x,y) */
		public const int CV_SEQ_ELTYPE_GRAPH_EDGE = 0;  /* &next_o, &next_d, &vtx_o, &vtx_d */
		public const int CV_SEQ_ELTYPE_GRAPH_VERTEX = 0;  /* first_edge, &(x,y) */
		public const int CV_SEQ_ELTYPE_TRIAN_ATR = 0;  /* vertex of the binary tree   */
		public const int CV_SEQ_ELTYPE_CONNECTED_COMP = 0;  /* connected component  */
		public static int CV_SEQ_ELTYPE_POINT3D = CV_32FC3;  /* (x,y,z)  */

		public const int CV_SEQ_KIND_BITS = 3;
		public const int CV_SEQ_KIND_MASK = (((1 << CV_SEQ_KIND_BITS) - 1) << CV_SEQ_ELTYPE_BITS);

		/* types of sequences */
		public const int CV_SEQ_KIND_GENERIC = (0 << CV_SEQ_ELTYPE_BITS);
		public const int CV_SEQ_KIND_CURVE = (1 << CV_SEQ_ELTYPE_BITS);
		public const int CV_SEQ_KIND_BIN_TREE = (2 << CV_SEQ_ELTYPE_BITS);

		/* types of sparse sequences (sets) */
		public const int CV_SEQ_KIND_GRAPH = (3 << CV_SEQ_ELTYPE_BITS);
		public const int CV_SEQ_KIND_SUBDIV2D = (4 << CV_SEQ_ELTYPE_BITS);

		public const int CV_SEQ_FLAG_SHIFT = (CV_SEQ_KIND_BITS + CV_SEQ_ELTYPE_BITS);

		/* flags for curves */
		public const int CV_SEQ_FLAG_CLOSED = (1 << CV_SEQ_FLAG_SHIFT);
		public const int CV_SEQ_FLAG_SIMPLE = (2 << CV_SEQ_FLAG_SHIFT);
		public const int CV_SEQ_FLAG_CONVEX = (4 << CV_SEQ_FLAG_SHIFT);
		public const int CV_SEQ_FLAG_HOLE = (8 << CV_SEQ_FLAG_SHIFT);

		/* flags for graphs */
		public const int CV_GRAPH_FLAG_ORIENTED = (1 << CV_SEQ_FLAG_SHIFT);

		public const int CV_GRAPH = CV_SEQ_KIND_GRAPH;
		public const int CV_ORIENTED_GRAPH = (CV_SEQ_KIND_GRAPH | CV_GRAPH_FLAG_ORIENTED);

		/* point sets */
		public static int CV_SEQ_POINT_SET = (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_POINT);
		public static int CV_SEQ_POINT3D_SET = (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_POINT3D);
		public static int CV_SEQ_POLYLINE = (CV_SEQ_KIND_CURVE | CV_SEQ_ELTYPE_POINT);
		public static int CV_SEQ_POLYGON = (CV_SEQ_FLAG_CLOSED | CV_SEQ_POLYLINE);
		public static int CV_SEQ_CONTOUR = CV_SEQ_POLYGON;
		public static int CV_SEQ_SIMPLE_POLYGON = (CV_SEQ_FLAG_SIMPLE | CV_SEQ_POLYGON);

		/* chain-coded curves */
		public static int CV_SEQ_CHAIN = (CV_SEQ_KIND_CURVE | CV_SEQ_ELTYPE_CODE);
		public static int CV_SEQ_CHAIN_CONTOUR = (CV_SEQ_FLAG_CLOSED | CV_SEQ_CHAIN);

		/* binary tree for the contour */
		public const int CV_SEQ_POLYGON_TREE = (CV_SEQ_KIND_BIN_TREE | CV_SEQ_ELTYPE_TRIAN_ATR);

		/* sequence of the connected components */
		public const int CV_SEQ_CONNECTED_COMP = (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_CONNECTED_COMP);

		/* sequence of the integer numbers */
		public int CV_SEQ_INDEX = (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_INDEX);

		public static int CV_SEQ_ELTYPE(CvSeq seq)
		{
			return (seq.flags & CV_SEQ_ELTYPE_MASK);
		}

		public static int CV_SEQ_KIND(CvSeq seq)
		{
			return (seq.flags & CV_SEQ_KIND_MASK);
		}

		public static int CV_SEQ_KIND(CvSet seq)
		{
			return (seq.flags & CV_SEQ_KIND_MASK);
		}

		/* flag checking */
		public static bool CV_IS_SEQ_INDEX(CvSeq seq)
		{
			return ((CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_INDEX) &&
			(CV_SEQ_KIND(seq) == CV_SEQ_KIND_GENERIC));
		}

		public static bool CV_IS_SEQ_CURVE(CvSeq seq)
		{
			return (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE);
		}

		public static bool CV_IS_SEQ_CLOSED(CvSeq seq)
		{
			return ((seq.flags & CV_SEQ_FLAG_CLOSED) != 0);
		}

		public static bool CV_IS_SEQ_CONVEX(CvSeq seq)
		{
			return ((seq.flags & CV_SEQ_FLAG_CONVEX) != 0);
		}

		public static bool CV_IS_SEQ_HOLE(CvSeq seq)
		{
			return ((seq.flags & CV_SEQ_FLAG_HOLE) != 0);
		}

		public static bool CV_IS_SEQ_SIMPLE(CvSeq seq)
		{
			return (((seq.flags & CV_SEQ_FLAG_SIMPLE) != 0) ||
						 CV_IS_SEQ_CONVEX(seq));
		}

		/* type checking macros */
		public static bool CV_IS_SEQ_POINT_SET(CvSeq seq)
		{
			return ((CV_SEQ_ELTYPE(seq) == CV_32SC2) || (CV_SEQ_ELTYPE(seq) == CV_32FC2));
		}

		public static bool CV_IS_SEQ_POINT_SUBSET(CvSeq seq)
		{
			return (CV_IS_SEQ_INDEX(seq) || (CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_PPOINT));
		}

		public static bool CV_IS_SEQ_POLYLINE(CvSeq seq)
		{
			return ((CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE) && CV_IS_SEQ_POINT_SET(seq));
		}

		public static bool CV_IS_SEQ_POLYGON(CvSeq seq)
		{
			return (CV_IS_SEQ_POLYLINE(seq) && CV_IS_SEQ_CLOSED(seq));
		}

		public static bool CV_IS_SEQ_CHAIN(CvSeq seq)
		{
			return ((CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE) && (seq.elem_size == 1));
		}

		public static bool CV_IS_SEQ_CONTOUR(CvSeq seq)
		{
			return (CV_IS_SEQ_CLOSED(seq) && (CV_IS_SEQ_POLYLINE(seq) || CV_IS_SEQ_CHAIN(seq)));
		}

		public static bool CV_IS_SEQ_CHAIN_CONTOUR(CvSeq seq)
		{
			return (CV_IS_SEQ_CHAIN(seq) && CV_IS_SEQ_CLOSED(seq));
		}

		public static bool CV_IS_SEQ_POLYGON_TREE(CvSeq seq)
		{
			return ((CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_TRIAN_ATR) &&
			(CV_SEQ_KIND(seq) == CV_SEQ_KIND_BIN_TREE));
		}

		public static bool CV_IS_GRAPH(CvSet seq)
		{
			return (CV_IS_SET(seq) && (CV_SEQ_KIND(seq) == CV_SEQ_KIND_GRAPH));
		}

		public static bool CV_IS_GRAPH_ORIENTED(CvSeq seq)
		{
			return ((seq.flags & CV_GRAPH_FLAG_ORIENTED) != 0);
		}

		public static bool CV_IS_SUBDIV2D(CvSeq seq)
		{
			return (CV_IS_SET(seq) && (CV_SEQ_KIND(seq) == CV_SEQ_KIND_SUBDIV2D));
		}

		/****************************************************************************************/
		/*                                Operations on sequences                               */
		/****************************************************************************************/

		public static IntPtr CV_SEQ_ELEM(ref CvSeq seq, int index)
   {
			return CvGetSeqElem( ref seq, index);
	 }

		public static IntPtr CV_GET_SEQ_ELEM(ref CvSeq seq, int index) 
	 {
		 return CV_SEQ_ELEM(ref seq, index);
	 }

		/* macro that adds element to sequence */
		public static void CV_WRITE_SEQ_ELEM_VAR(IntPtr elem_ptr, ref CvSeqWriter writer)
		{
			if (writer.pt.ToInt32() >= writer.block_max.ToInt32())
			{
				CvCreateSeqBlock(ref writer);
			}
			int size = ((CvSeq)Marshal.PtrToStructure(writer.seq, typeof(CvSeq))).elem_size;
			memcpy(writer.pt, elem_ptr, size);
			writer.pt = new IntPtr(writer.pt.ToInt32() + size);          
		}

		public static void CV_WRITE_SEQ_ELEM(IntPtr elem, ref CvSeqWriter writer)
		{
			if (writer.pt.ToInt32() >= writer.block_max.ToInt32())
			{
				CvCreateSeqBlock(ref writer);
			}
			int size = ((CvSeq)Marshal.PtrToStructure(writer.seq, typeof(CvSeq))).elem_size;
			memcpy(writer.pt, elem, size);
			writer.pt = new IntPtr(writer.pt.ToInt32() + size);
		}


		///* move reader position forward */
		public static void CV_NEXT_SEQ_ELEM(int elem_size, ref CvSeqReader reader)
		{
			reader.pt = new IntPtr(reader.pt.ToInt32() + elem_size);
			if (reader.pt.ToInt32() >= reader.block_max.ToInt32())
			{
				CvChangeSeqBlock(ref reader, 1);
			}
		}


		/* move reader position backward */
		public static void CV_PREV_SEQ_ELEM(int elem_size, ref CvSeqReader reader)
		{
			reader.pt = new IntPtr(reader.pt.ToInt32() - elem_size);
			if (reader.pt.ToInt32() >= reader.block_min.ToInt32())
			{
				CvChangeSeqBlock(ref reader, -1);
			}
		}

		/* read element and move read position forward */
		public static void CV_READ_SEQ_ELEM(ref CvPoint point, ref CvSeqReader reader)
		{
			point = (CvPoint)Marshal.PtrToStructure(reader.pt, typeof(CvPoint));
			CV_NEXT_SEQ_ELEM(Marshal.SizeOf(typeof(CvPoint)), ref reader);
		}

		/* read element and move read position backward */
		public static void CV_REV_READ_SEQ_ELEM(ref CvPoint point, ref CvSeqReader reader)                     
		{
			point = (CvPoint)Marshal.PtrToStructure(reader.pt, typeof(CvPoint));          
		  CV_PREV_SEQ_ELEM(Marshal.SizeOf(typeof(CvPoint)), ref reader);                
		}

		//public void CV_READ_CHAIN_POINT(ref CvPoint _pt, ref CvChainPtReader reader)      
		//{
		//  _pt = reader.pt;
		//  if(reader.ptr1 != IntPtr.Zero)                                                  
		//  {
		//    IntPtr ptr = new IntPtr();            
		//    CV_READ_SEQ_ELEM(ptr, sizeof(CvPoint), ref reader);
		//    reader.code = Marshal.ReadByte(ptr);            
		//    Debug.Assert((reader.code & ~7) == 0);
		//    int[][] arr = new int[8][];
		//    arr[0] = new int[2]; arr[1] = new int[2]; arr[2] = new int[2]; arr[3] = new int[2];
		//    arr[4] = new int[2]; arr[5] = new int[2]; arr[6] = new int[2]; arr[7] = new int[2];
		//    cvtools.Convert2DArrToPtr(arr, out h);
		//    reader.pt.x += reader.deltas[(int)(reader).code][0];        
		//    reader.pt.y += (reader).deltas[(int)(reader).code][1];        
		//    }                                                                   
		//}

		//#define CV_CURRENT_POINT( reader )  (*((CvPoint*)((reader).ptr)))
		//#define CV_PREV_POINT( reader )     (*((CvPoint*)((reader).prev_elem)))

		//#define CV_READ_EDGE( pt1, pt2, reader )               
		//{                                                      
		//    assert( sizeof(pt1) == sizeof(CvPoint) &&          
		//            sizeof(pt2) == sizeof(CvPoint) &&          
		//            reader.seq->elem_size == sizeof(CvPoint)); 
		//    (pt1) = CV_PREV_POINT( reader );                   
		//    (pt2) = CV_CURRENT_POINT( reader );                
		//    (reader).prev_elem = (reader).ptr;                 
		//    CV_NEXT_SEQ_ELEM( sizeof(CvPoint), (reader));      
		//}

		///************ Graph macros ************/

		///* returns next graph edge for given vertex */
		//#define  CV_NEXT_GRAPH_EDGE( edge, vertex )                              
		//     (assert((edge)->vtx[0] == (vertex) || (edge)->vtx[1] == (vertex)),  
		//      (edge)->next[(edge)->vtx[1] == (vertex)])



		///****************************************************************************************
		//*             Data structures for persistence (a.k.a serialization) functionality        *
		//****************************************************************************************/

		///* "black box" file storage */
		//typedef struct CvFileStorage CvFileStorage;

		///* storage flags */
		public const int CV_STORAGE_READ = 0;
		public const int CV_STORAGE_WRITE = 1;
		public const int CV_STORAGE_WRITE_TEXT = CV_STORAGE_WRITE;
		public const int CV_STORAGE_WRITE_BINARY = CV_STORAGE_WRITE;
		public const int CV_STORAGE_APPEND = 2;

		CvAttrList CvAttrList(IntPtr attr, IntPtr next)
		{
		    CvAttrList l = new CvAttrList();
		    l.attr = attr;
		    l.next = next;
		    return l;
		}

		public const int CV_NODE_NONE        = 0;
		public const int CV_NODE_INT         = 1;
		public const int CV_NODE_INTEGER     = CV_NODE_INT;
		public const int CV_NODE_REAL        = 2;
		public const int CV_NODE_FLOAT       = CV_NODE_REAL;
		public const int CV_NODE_STR         = 3;
		public const int CV_NODE_STRING      = CV_NODE_STR;
		public const int CV_NODE_REF         = 4; /* not used */
		public const int CV_NODE_SEQ         = 5;
		public const int CV_NODE_MAP         = 6;
		public const int CV_NODE_TYPE_MASK   = 7;

		public static int CV_NODE_TYPE(int flags) { return ((flags) & CV_NODE_TYPE_MASK);}

		/* file node flags */
		public const int CV_NODE_FLOW        = 8; /* used only for writing structures to YAML format */
		public const int CV_NODE_USER        = 16;
		public const int CV_NODE_EMPTY       = 32;
		public const int CV_NODE_NAMED       = 64;

		public static bool CV_NODE_IS_INT(int flags) { return (CV_NODE_TYPE(flags) == CV_NODE_INT); }
		public static bool CV_NODE_IS_REAL(int flags) { return (CV_NODE_TYPE(flags) == CV_NODE_REAL); }
		public static bool CV_NODE_IS_STRING(int flags) { return (CV_NODE_TYPE(flags) == CV_NODE_STRING); }
		public static bool CV_NODE_IS_SEQ(int flags) { return (CV_NODE_TYPE(flags) == CV_NODE_SEQ); }
		public static bool CV_NODE_IS_MAP(int flags) { return (CV_NODE_TYPE(flags) == CV_NODE_MAP); }
		public static bool CV_NODE_IS_COLLECTION(int flags) { return (CV_NODE_TYPE(flags) >= CV_NODE_SEQ); }
		public static bool CV_NODE_IS_FLOW(int flags) { return (((flags) & CV_NODE_FLOW) != 0); }
		public static bool CV_NODE_IS_EMPTY(int flags) { return (((flags) & CV_NODE_EMPTY) != 0); }
		public static bool CV_NODE_IS_USER(int flags) { return (((flags) & CV_NODE_USER) != 0); }
		public static bool CV_NODE_HAS_NAME(int flags) { return (((flags) & CV_NODE_NAMED) != 0); }

		public const int CV_NODE_SEQ_SIMPLE = 256;
		
		// ToDo
		//public static int CV_NODE_SEQ_IS_SIMPLE(int seq) { return (((seq)->flags & CV_NODE_SEQ_SIMPLE) != 0);}

		/********************
		* Matrix type (CvMat)
		*********************/
		public const int CV_CN_MAX = 64;
		public const int CV_CN_SHIFT = 3;
		public const int CV_DEPTH_MAX = (1 << CV_CN_SHIFT);
		public const int CV_8U = 0;
		public const int CV_8S = 1;
		public const int CV_16U = 2;
		public const int CV_16S = 3;
		public const int CV_32S = 4;
		public const int CV_32F = 5;
		public const int CV_64F = 6;
		public const int CV_USRTYPE1 = 7;


		public static int CV_MAKETYPE(int depth, int cn)
		{
			return ((depth) + (((cn) - 1) << CV_CN_SHIFT));
		}

		public static int CV_MAKE_TYPE(int depth, int cn)
		{
			return ((depth) + (((cn) - 1) << CV_CN_SHIFT));
		}

		public static int CV_8UC1 = CV_MAKETYPE(CV_8U, 1);
		public static int CV_8UC2 = CV_MAKETYPE(CV_8U, 2);
		public static int CV_8UC3 = CV_MAKETYPE(CV_8U, 3);
		public static int CV_8UC4 = CV_MAKETYPE(CV_8U, 4);
		public static int CV_8UC(int n) { return CV_MAKETYPE(CV_8U, (n)); }

		public static int CV_8SC1 = CV_MAKETYPE(CV_8S, 1);
		public static int CV_8SC2 = CV_MAKETYPE(CV_8S, 2);
		public static int CV_8SC3 = CV_MAKETYPE(CV_8S, 3);
		public static int CV_8SC4 = CV_MAKETYPE(CV_8S, 4);
		public static int CV_8SC(int n) { return CV_MAKETYPE(CV_8S, (n)); }

		public static int CV_16UC1 = CV_MAKETYPE(CV_16U, 1);
		public static int CV_16UC2 = CV_MAKETYPE(CV_16U, 2);
		public static int CV_16UC3 = CV_MAKETYPE(CV_16U, 3);
		public static int CV_16UC4 = CV_MAKETYPE(CV_16U, 4);
		public static int CV_16UC(int n) { return CV_MAKETYPE(CV_16U, (n)); }

		public static int CV_16SC1 = CV_MAKETYPE(CV_16S, 1);
		public static int CV_16SC2 = CV_MAKETYPE(CV_16S, 2);
		public static int CV_16SC3 = CV_MAKETYPE(CV_16S, 3);
		public static int CV_16SC4 = CV_MAKETYPE(CV_16S, 4);
		public static int CV_16SC(int n) { return CV_MAKETYPE(CV_16S, (n)); }

		public static int CV_32SC1 = CV_MAKETYPE(CV_32S, 1);
		public static int CV_32SC2 = CV_MAKETYPE(CV_32S, 2);
		public static int CV_32SC3 = CV_MAKETYPE(CV_32S, 3);
		public static int CV_32SC4 = CV_MAKETYPE(CV_32S, 4);
		public static int CV_32SC(int n) { return CV_MAKETYPE(CV_32S, (n)); }

		public static int CV_32FC1 = CV_MAKETYPE(CV_32F, 1);
		public static int CV_32FC2 = CV_MAKETYPE(CV_32F, 2);
		public static int CV_32FC3 = CV_MAKETYPE(CV_32F, 3);
		public static int CV_32FC4 = CV_MAKETYPE(CV_32F, 4);
		public static int CV_32FC(int n) { return CV_MAKETYPE(CV_32F, (n)); }

		public static int CV_64FC1 = CV_MAKETYPE(CV_64F, 1);
		public static int CV_64FC2 = CV_MAKETYPE(CV_64F, 2);
		public static int CV_64FC3 = CV_MAKETYPE(CV_64F, 3);
		public static int CV_64FC4 = CV_MAKETYPE(CV_64F, 4);
		public static int CV_64FC(int n) { return CV_MAKETYPE(CV_64F, (n)); }

		public const int CV_AUTO_STEP = 0x7fffffff;
		public CvSlice CV_WHOLE_ARR = new CvSlice(0, 0x3fffffff);

		public const int CV_MAT_CN_MASK = ((CV_CN_MAX - 1) << CV_CN_SHIFT);
		public static int CV_MAT_CN(int flags) { return ((((flags) & CV_MAT_CN_MASK) >> CV_CN_SHIFT) + 1); }
		public const int CV_MAT_DEPTH_MASK = (CV_DEPTH_MAX - 1);
		public static int CV_MAT_DEPTH(int flags) { return ((flags) & CV_MAT_DEPTH_MASK); }
		public const int CV_MAT_TYPE_MASK = (CV_DEPTH_MAX * CV_CN_MAX - 1);
		public static int CV_MAT_TYPE(int flags) { return ((flags) & CV_MAT_TYPE_MASK); }
		public const int CV_MAT_CONT_FLAG_SHIFT = 14;
		public const int CV_MAT_CONT_FLAG = (1 << CV_MAT_CONT_FLAG_SHIFT);
		public static int CV_IS_MAT_CONT(int flags) { return ((flags) & CV_MAT_CONT_FLAG); }
		public static int CV_IS_CONT_MAT(int flags) { return ((flags) & CV_MAT_CONT_FLAG); }
		public const int CV_MAT_TEMP_FLAG_SHIFT = 15;
		public const int CV_MAT_TEMP_FLAG = (1 << CV_MAT_TEMP_FLAG_SHIFT);
		public static int CV_IS_TEMP_MAT(int flags) { return ((flags) & CV_MAT_TEMP_FLAG); }

		public const uint CV_MAGIC_MASK = 0xFFFF0000;
		public const int CV_MAT_MAGIC_VAL = 0x42420000;
		public const string CV_TYPE_NAME_MAT = "opencv-matrix";

		const double CV_PI = 3.1415926535897932384626433832795;
		const double CV_LOG2 = 0.69314718055994530941723212145818;
		
		/**************************
		 * Random number generation
		 * ************************/
		public static ulong CvRNG(int seed)
		{
			Random rnd = new Random();
			ulong rng = (ulong)rnd.Next(seed);
			return rng;
		}

		public static bool CV_IS_MAT_HDR(CvMat mat)
		{
			return ((mat.type & CV_MAGIC_MASK) == CV_MAT_MAGIC_VAL) &&
			(mat.cols > 0) && (mat.rows > 0);
		}

		public static bool CV_IS_MAT(CvMat mat)
		{
			return (CV_IS_MAT_HDR(mat) && (mat.data != IntPtr.Zero));
		}

		public static bool CV_IS_MASK_ARR(CvMat mat)
		{
			return ((mat.type & (CV_MAT_TYPE_MASK & ~CV_8SC1)) == 0);
		}

		public static bool CV_ARE_TYPES_EQ(CvMat mat1, CvMat mat2)
		{
			return (((mat1.type ^ mat2.type) & CV_MAT_TYPE_MASK) == 0);
		}

		public static bool CV_ARE_CNS_EQ(CvMat mat1, CvMat mat2)
		{
			return (((mat1.type ^ mat2.type) & CV_MAT_CN_MASK) == 0);
		}

		public static bool CV_ARE_DEPTHS_EQ(CvMat mat1, CvMat mat2)
		{
			return (((mat1.type ^ mat2.type) & CV_MAT_DEPTH_MASK) == 0);
		}

		public static bool CV_ARE_SIZES_EQ(CvMat mat1, CvMat mat2)
		{
			return (mat1.height == mat2.height) && (mat1.width == mat2.width);
		}

		public static bool CV_IS_MAT_CONST(CvMat mat)
		{
			return ((mat.height | mat.width) == 1);
		}

		/* size of each channel item,
			0x124489 = 1000 0100 0100 0010 0010 0001 0001 ~ array of sizeof(arr_type_elem) */
		public static int CV_ELEM_SIZE1(int type)
		{
			return ((((sizeof(int) << 28) | 0x8442211) >> CV_MAT_DEPTH(type) * 4) & 15);
		}

		/* 0x3a50 = 11 10 10 01 01 00 00 ~ array of log2(sizeof(arr_type_elem)) */
		public static int CV_ELEM_SIZE(int type)
		{
			return (CV_MAT_CN(type) << ((((sizeof(int) / 4 + 1) * 16384 | 0x3a50) >> CV_MAT_DEPTH(type) * 2) & 3));
		}

		// ToDo
		public static CvMat CvMat(int rows, int cols, ref int type)
		{
			CvMat m = new CvMat();

			Debug.Assert((uint)CV_MAT_DEPTH(type) <= CV_64F);
			type = CV_MAT_TYPE(type);
			m.type = CV_MAT_MAGIC_VAL | CV_MAT_CONT_FLAG | type;
			m.cols = cols;
			m.rows = rows;
			m.step = rows > 1 ? m.cols * CV_ELEM_SIZE(type) : 0;
			//m.i = data;
			m.refcount = IntPtr.Zero;
			m.hdr_refcount = 0;

			return m;
		}

		public static double cvmGet(CvMat mat, int row, int col)
		{
			int type;
			type = CV_MAT_TYPE(mat.type);
			Debug.Assert((uint)row < (uint)mat.rows && (uint)col < (uint)mat.cols);
			Debug.Assert(type == CV_64FC1);
			return CvGetReal2D(ref mat, row, col);
			//return mat.db[mat.step * row + col];
		}

		public static void cvmSet(ref CvMat mat, int row, int col, double value)
		{
		  int type;
		  type = CV_MAT_TYPE(mat.type);
		  Debug.Assert((uint)row < (uint)mat.rows && (uint)col < (uint)mat.cols);

		  Debug.Assert(type == CV_64FC1);
			CvSetReal2D(ref mat, row, col, value);
			//mat.db[mat.step * row + col] = value;
		}

		public static uint cvCvToIplDepth(int type)
		{
			int depth = CV_MAT_DEPTH(type);
			uint t = (depth == CV_8S || depth == CV_16S || depth == CV_32S ? IPL_DEPTH_SIGN : 0);
			uint t1 = ((uint)CV_ELEM_SIZE1(depth) * (uint)8);
			return t1 | t;
		}

		public static CvPoint CvPoint(int x, int y)
		{
			CvPoint p = new CvPoint();

			p.x = x;
			p.y = y;

			return p;
		}

		public static CvPoint2D32f CvPoint2D32f(double x, double y)
		{
			CvPoint2D32f p = new CvPoint2D32f();

			p.x = (float)x;
			p.y = (float)y;

			return p;
		}

		public static CvPoint2D32f CvPointTo32f(CvPoint point)
		{
			return CvPoint2D32f((float)point.x, (float)point.y);
		}

		public static CvPoint CvPointFrom32f(CvPoint2D32f point)
		{
			CvPoint ipt = new CvPoint();
			ipt.x = CvRound(point.x);
			ipt.y = CvRound(point.y);

			return ipt;
		}

		public static CvPoint3D32f CvPoint3D32f(double x, double y, double z)
		{
			CvPoint3D32f p = new CvPoint3D32f();

			p.x = (float)x;
			p.y = (float)y;
			p.z = (float)z;

			return p;
		}

		public static CvPoint2D64f CvPoint2D64f(double x, double y)
		{
			CvPoint2D64f p = new CvPoint2D64f();

			p.x = x;
			p.y = y;

			return p;
		}

		public static CvPoint3D64f CvPoint3D64f(double x, double y, double z)
		{
			CvPoint3D64f p = new CvPoint3D64f();

			p.x = x;
			p.y = y;
			p.z = z;

			return p;
		}

		public static CvSize CvSize(int width, int height)
		{
			CvSize s = new CvSize();

			s.width = width;
			s.height = height;

			return s;
		}

		public static CvSize2D32f CvSize2D32f(double width, double height)
		{
			CvSize2D32f s = new CvSize2D32f();

			s.width = (float)width;
			s.height = (float)height;

			return s;
		}

		public static CvMat CvMat(int rows, int cols, int type, IntPtr data)
		{
			CvMat m = new CvMat();

			//assert((unsigned)CV_MAT_DEPTH(type) <= CV_64F);
			type = CV_MAT_TYPE(type);
			m.type = CV_MAT_MAGIC_VAL | CV_MAT_CONT_FLAG | type;
			m.cols = cols;
			m.rows = rows;
			m.step = rows > 1 ? m.cols * CV_ELEM_SIZE(type) : 0;
			m.data = data;
			m.refcount = IntPtr.Zero;
			m.hdr_refcount = 0;

			return m;
		}

	}
}
