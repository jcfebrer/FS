//*******************************************************************
// File name: $ highgui.cs $
// Author:		$ Heiko Kieﬂling, (c) iib-chemnitz.de $
//						RoiParam & ToBitmap partially from EmGuCv but adapted (see article)
// Email:			hki@hrz.tu-chemnitz.de
// 
// License:		There is no explicit license attached. The code is
//						provided 'as is'. Feel free to use the code how you like 
//						but without any warranty.
//						If you include the code in your own projects and/or
//						redistribute pls. include this header.
//
// History:		Rev. 1.0 (beta), hki - initial revision
// ToDo:			Documentation
//*******************************************************************
// Code generated by cvDocParser V1.0
//*******************************************************************


using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;

namespace openCV
{
	public partial class cvlib
	{
		#if DEBUG
			private const string HIGHGUI_LIBRARY = "highgui100d.dll";
		#else
			private const string HIGHGUI_LIBRARY = "highgui100.dll";
		#endif

			/// <summary>
			/// Loads an image from file
			/// </summary>
			/// <param name="path">Path to the file to be loaded.</param>
			/// <param name="flags">Specifies colorness and depth of the loaded image:
			/// The colorness specifies whether the loaded image is to be converted to 3 channels (CV_LOAD_IMAGE_COLOR), 1 channel (CV_LOAD_IMAGE_GRAYSCALE), or left as it was in the input file (CV_LOAD_IMAGE_ANYCOLOR).
			/// Depth specifies whether the loaded image is to be converted to 8 bits per pixel per color channel as was customary in previous versions of OpenCV or left as they were in the input file. If CV_LOAD_IMAGE_ANYDEPTH is passed the pixel format can be 8 bit unsigned, 16 bit unsigned, 32 bit signed or 32 bit floating point.
			/// If conflicting flags are passed the flag with the smaller numerical value wins. That is if CV_LOAD_IMAGE_COLOR | CV_LOAD_IMAGE_ANYCOLOR is passed the image is loaded with 3 channels. CV_LOAD_IMAGE_ANYCOLOR is equivalent to specifying CV_LOAD_IMAGE_UNCHANGED. However, CV_LOAD_IMAGE_ANYCOLOR has the advantage that it can be combined with CV_LOAD_IMAGE_ANYDEPTH. So CV_LOAD_IMAGE_UNCHANGED should not be used any longer.
			/// If you want to load the image as truthfully as possible pass CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR.</param>
			/// <returns>IplImage</returns>
		public static IplImage CvLoadImage(string path, int flags)
		{
			IntPtr p = cvLoadImage(path, flags);
			IplImage i;
			i= (IplImage)Marshal.PtrToStructure(p, typeof(IplImage));
			i.ptr = p;
			return i;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvLoadImage([MarshalAs(UnmanagedType.LPStr)] String filename, int flags);

		/// <summary>
		/// Loads an image from file
		/// </summary>
		/// <param name="path">Name of file to be loaded.</param>
		/// <param name="flags">Specifies colorness and depth of the loaded image:
		/// The colorness specifies whether the loaded image is to be converted to 3 channels (CV_LOAD_IMAGE_COLOR), 1 channel (CV_LOAD_IMAGE_GRAYSCALE), or left as it was in the input file (CV_LOAD_IMAGE_ANYCOLOR).
		/// Depth specifies whether the loaded image is to be converted to 8 bits per pixel per color channel as was customary in previous versions of OpenCV or left as they were in the input file. If CV_LOAD_IMAGE_ANYDEPTH is passed the pixel format can be 8 bit unsigned, 16 bit unsigned, 32 bit signed or 32 bit floating point.
		/// If conflicting flags are passed the flag with the smaller numerical value wins. That is if CV_LOAD_IMAGE_COLOR | CV_LOAD_IMAGE_ANYCOLOR is passed the image is loaded with 3 channels. CV_LOAD_IMAGE_ANYCOLOR is equivalent to specifying CV_LOAD_IMAGE_UNCHANGED. However, CV_LOAD_IMAGE_ANYCOLOR has the advantage that it can be combined with CV_LOAD_IMAGE_ANYDEPTH. So CV_LOAD_IMAGE_UNCHANGED should not be used any longer.
		/// If you want to load the image as truthfully as possible pass CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR.</param>
		/// <returns>IplImage</returns>
		public static void CvSaveImage(string path, ref IplImage img)
		{
			cvSaveImage(path, img.ptr);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvSaveImage([MarshalAs(UnmanagedType.LPStr)] String filename, IntPtr img);

		/// <summary>
		/// Converts IplImage to Windows Bitmap
		/// Only IPL_DEPTH_8U is supported
		/// Only interleaved images are supported
		/// Only 3 channels Images are supported
		/// </summary>
		/// <param name="image">IplImage to convert</param>
		/// <param name="dispose">If true IplImage will be disposed</param>
		/// <returns>Bitmap with Format24bppRgb</returns>
		public static Bitmap ToBitmap(IplImage image, bool dispose)
		{
			if (image.dataOrder != 0)
			{
				throw new Exception("Only interleaved Images are supported for conversion to Bitmap");
			}

	
			if (image.nChannels != 3 || image.depth != IPL_DEPTH_8U)
			{
				throw new Exception("Only 3 Channel and IPL_DEPTH_8U images are supported for conversion to Bitmap");
			}


			CvSize size;
			int Width = size.width = image.width;
			int Height = size.height = image.height;

			//create the bitmap and get the pointer to the data
			Bitmap gdiBmp;
			PixelFormat fmt;
			fmt = PixelFormat.Format24bppRgb;
			gdiBmp = new Bitmap(Width, Height, fmt);

			BitmapData data = gdiBmp.LockBits(new Rectangle(0, 0, Width, Height),
					ImageLockMode.WriteOnly, fmt);
			int dataPtr = data.Scan0.ToInt32();

			int start, elementCount, byteWidth, rows, widthStep;
			RoiParam(image, out start, out rows, out elementCount, out byteWidth, out widthStep);
			for (int row = 0; row < data.Height; row++, start += widthStep, dataPtr += data.Stride)
				memcpy((IntPtr)dataPtr, (IntPtr)start, data.Stride);

			gdiBmp.UnlockBits(data);

			if (dispose) CvReleaseImage(ref image);
			return gdiBmp;
		}

		/// <summary>
		/// Converts Bitmap Image to IplImage
		/// Only PixelFormat.Format24bppRgb or 
		/// PixelFormat.Format8bppIndexed is supported
		/// </summary>
		/// <param name="image">Bitmap to convert</param>
		/// <param name="dispose">If true the Bitmap will be disposed</param>
		/// <returns>IplImage either 3 or 1 channels with Depht 8U</returns>
		public static IplImage ToIplImage(Bitmap img, bool dispose)
		{
			IplImage iplImage;
			BitmapData data;

			// check format (Es darf nicht das UND es darf nicht das andere sein)
			if (img.PixelFormat != PixelFormat.Format24bppRgb && img.PixelFormat != PixelFormat.Format8bppIndexed)
			{
				throw new Exception("Only unsigned 8/24 Bit Image Depht are supported for conversion to IplImage");
			}

			// set size
			CvSize size = new CvSize(img.Width, img.Height);
			
			// create
			if (img.PixelFormat == PixelFormat.Format24bppRgb)
			{
				iplImage = cvlib.CvCreateImage(size, (int)cvlib.IPL_DEPTH_8U, 3);
				data = img.LockBits(new Rectangle(0, 0, size.width, 
				size.height), ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb);
			}
			else
			{
				iplImage = cvlib.CvCreateImage(size, (int)cvlib.IPL_DEPTH_8U, 1);
				data = img.LockBits(new Rectangle(0, 0, size.width, 
				size.height), ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);
			}

			// copy data
			int dataPtr = data.Scan0.ToInt32();

			int start, elementCount, byteWidth, rows, widthStep;
			RoiParam(iplImage, out start, out rows, out elementCount, out byteWidth, out widthStep);
			for (int row = 0; row < data.Height; row++, start += widthStep, dataPtr += data.Stride)
				memcpy((IntPtr)start,(IntPtr)dataPtr, data.Stride);

			img.UnlockBits(data);

			if (dispose) img.Dispose();

			return iplImage;
		}

		/// <summary>
		/// get ROI params
		/// </summary>
		/// <param name="start"></param>
		/// <param name="rows"></param>
		/// <param name="elementCount"></param>
		/// <param name="byteWidth"></param>
		/// <param name="widthStep"></param>
		private static void RoiParam(IplImage img, out int start, out int rows, out int elementCount, out int byteWidth, out int widthStep)
		{
			start = img.imageData.ToInt32();
			widthStep = img.widthStep;

			if (img.roi != IntPtr.Zero)
			{
				CvRect rec = CvGetImageROI(ref img);
				elementCount = rec.width * img.nChannels;
				byteWidth = (img.depth >> 3) * elementCount;

				start += rec.y * widthStep + (img.depth >> 3) * rec.x;
				rows = rec.height;
			}
			else
			{
				byteWidth = widthStep;
				elementCount = img.width * img.nChannels;
				rows = img.height;
			}
		}

		/// <summary>
		/// classic memcopy
		/// </summary>
		/// <param name="dest">dst ptr</param>
		/// <param name="src">src ptr</param>
		/// <param name="len">lenght of mem block</param>
		[DllImport("kernel32.dll", EntryPoint = "CopyMemory")]
		public static extern void memcpy(IntPtr dest, IntPtr src, int len);

		/// <summary>
		/// The function cvCreateFileCapture allocates and 
		/// initialized the CvCapture structure for reading the 
		/// video stream from the specified file.
		/// </summary>
		/// <param name="path">Name of the video file.</param>
		/// <returns>CvCapture structure</returns>
		public static CvCapture CvCreateFileCapture(string path)
		{
			CvCapture c = new CvCapture();
			c.ptr = cvCreateFileCapture(path);
			return c;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvCreateFileCapture([MarshalAs(UnmanagedType.LPStr)] String filename);

		/// <summary>
		/// The function cvCreateCameraCapture allocates and initialized 
		/// the CvCapture structure for reading a video stream from the 
		/// camera. Currently two camera interfaces can be used on Windows: 
		/// Video for Windows (VFW) and Matrox Imaging Library (MIL); 
		/// </summary>
		/// <param name="idx">Index of the camera to be used. If there is 
		/// only one camera or it does not matter what camera to use -1 
		/// may be passed.</param>
		/// <returns>CvCapture structure</returns>
		public static CvCapture CvCreateCameraCapture(int idx)
		{
			CvCapture c = new CvCapture();
			c.ptr = cvCreateCameraCapture(idx);
			return c;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvCreateCameraCapture(int idx);

		/// <summary>
		/// The function cvReleaseCapture releases the CvCapture
		/// structure allocated by cvCreateFileCapture or cvCreateCameraCapture.
		/// </summary>
		/// <param name="capture">Video capturing structure.</param>
		public static void CvReleaseCapture( ref CvCapture capture )
		{
			cvReleaseCapture(ref capture.ptr);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvReleaseCapture(ref IntPtr ptr);

		/// <summary>
		/// The function cvGrabFrame grabs the frame from camera or file. 
		/// The grabbed frame is stored internally. The purpose of this 
		/// function is to grab frame fast that is important for 
		/// syncronization in case of reading from several cameras simultaneously. 
		/// The grabbed frames are not exposed because they may be stored in 
		/// compressed format (as defined by camera/driver). To retrieve the 
		/// grabbed frame, cvRetrieveFrame should be used.
		/// </summary>
		/// <param name="capture">video capturing structure.</param>
		/// <returns>1 if succsess</returns>
		public static int CvGrabFrame( ref CvCapture capture )
		{
			return cvGrabFrame(capture.ptr);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern int cvGrabFrame(IntPtr ptr);

		/// <summary>
		/// The function cvRetrieveFrame returns the pointer to the image 
		/// grabbed with cvGrabFrame function. The returned image should 
		/// not be released or modified by user.
		/// </summary>
		/// <param name="capture">video capturing structure.</param>
		/// <returns>Image</returns>
		public static IplImage CvRetrieveFrame(ref CvCapture capture)
		{
			IntPtr p = cvRetrieveFrame(capture.ptr);
			IplImage i;
			i = (IplImage)Marshal.PtrToStructure(p, typeof(IplImage));
			i.ptr = p;
			return i;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvRetrieveFrame(IntPtr ptr);

		/// <summary>
		/// The function cvQueryFrame grabs a frame from camera 
		/// or video file, decompresses and returns it. This function 
		/// is just a combination of cvGrabFrame and cvRetrieveFrame 
		/// in one call. The returned image should not be released or 
		/// modified by user.
		/// </summary>
		/// <param name="capture">video capturing structure.</param>
		/// <returns>Image</returns>
		public static IplImage CvQueryFrame(ref CvCapture capture)
		{
			IntPtr p = cvQueryFrame(capture.ptr);
			IplImage i;
			i = (IplImage)Marshal.PtrToStructure(p, typeof(IplImage));
			i.ptr = p;
			return i;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvQueryFrame(IntPtr ptr);

		/// <summary>
		/// The function cvQueryFrameFast is same like query frame
		/// but returns pointer and has optional Flip param
		/// </summary>
		/// <param name="capture">video capturing structure.</param>
		/// <returns>Image</returns>
		public static IntPtr CvQueryFrame(ref CvCapture capture, bool flip)
		{
			IntPtr src = cvQueryFrame(capture.ptr);
			if (flip) cvFlip(src, IntPtr.Zero, 0);
			return src;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvFlip(IntPtr src, IntPtr dst, int mode);

		/// <summary>
		/// The function cvGetCaptureProperty retrieves the specified 
		/// property of camera or video file.
		/// </summary>
		/// <param name="capture">video capturing structure.</param>
		/// <param name="property_id">property identifier. Can be one of the following:
		/// CV_CAP_PROP_POS_MSEC - film current position in milliseconds or video capture timestamp
		/// CV_CAP_PROP_POS_FRAMES - 0-based index of the frame to be decoded/captured next
		/// CV_CAP_PROP_POS_AVI_RATIO - relative position of video file (0 - start of the film, 1 - end of the film)
		/// CV_CAP_PROP_FRAME_WIDTH - width of frames in the video stream
		/// CV_CAP_PROP_FRAME_HEIGHT - height of frames in the video stream
		/// CV_CAP_PROP_FPS - frame rate
		/// CV_CAP_PROP_FOURCC - 4-character code of codec. CV_CAP_PROP_FRAME_COUNT - number of frames in video file.
		/// </param>
		/// <returns>value</returns>
		public static double cvGetCaptureProperty(CvCapture capture, int property_id)
		{
			return cvGetCaptureProperty(capture.ptr, property_id);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern double cvGetCaptureProperty(IntPtr ptr, int property_id);

		/// <summary>
		/// The function cvGetCaptureProperty sets the specified 
		/// property of camera or video file.
		/// </summary>
		/// <param name="capture">video capturing structure.</param>
		/// <param name="property_id">property identifier. Can be one of the following:
		/// CV_CAP_PROP_POS_MSEC - film current position in milliseconds or video capture timestamp
		/// CV_CAP_PROP_POS_FRAMES - 0-based index of the frame to be decoded/captured next
		/// CV_CAP_PROP_POS_AVI_RATIO - relative position of video file (0 - start of the film, 1 - end of the film)
		/// CV_CAP_PROP_FRAME_WIDTH - width of frames in the video stream
		/// CV_CAP_PROP_FRAME_HEIGHT - height of frames in the video stream
		/// CV_CAP_PROP_FPS - frame rate
		/// CV_CAP_PROP_FOURCC - 4-character code of codec. CV_CAP_PROP_FRAME_COUNT - number of frames in video file.
		/// </param>
		/// <param name="value">the value to be set</param>
		public static int CvSetCaptureProperty( ref CvCapture capture, int property_id, double value )
		{
			return cvSetCaptureProperty(capture.ptr, property_id, value);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern int cvSetCaptureProperty(IntPtr ptr, int property_id, double value);

		/// <summary>
		/// The function cvCreateVideoWriter creates video writer structure.
		/// </summary>
		/// <param name="filename">Name of the output video file.</param>
		/// <param name="fourcc">4-character code of codec used to compress 
		/// the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, 
		/// CV_FOURCC('M','J','P','G') is motion-jpeg codec etc. 
		/// Under Win32 it is possible to pass -1 in order to choose compression 
		/// method and additional compression parameters from dialog.</param>
		/// <param name="fps">Framerate of the created video stream.</param>
		/// <param name="frame_size">Size of video frames</param>
		/// <param name="is_color">If it is not zero, the encoder will expect 
		/// and encode color frames, otherwise it will work with grayscale 
		/// frames (the flag is currently supported on Windows only).</param>
		/// <returns>Video writer structure (ptr only)</returns>
		public static CvVideoWriter CvCreateVideoWriter(string filename, int fourcc, double fps, CvSize frame_size, int is_color)
		{
			CvVideoWriter vw = new CvVideoWriter();
			vw.ptr = cvCreateVideoWriter(filename, fourcc, fps, frame_size, is_color);
			return vw;
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvCreateVideoWriter([MarshalAs(UnmanagedType.LPStr)] String filename, int fourcc, double fps, CvSize frame_size, int is_color);

		/// <summary>
		/// The function cvReleaseVideoWriter finishes writing 
		/// to video file and releases the structure.
		/// </summary>
		/// <param name="vw">Pointer to video file writer structure.</param>
		public static void CvReleaseVideoWriter(ref CvVideoWriter vw)
		{
			cvReleaseVideoWriter(ref vw.ptr);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvReleaseVideoWriter(ref IntPtr ptr);

		/// <summary>
		/// ConvertImage
		/// The function cvConvertImage converts one image to another 
		/// and flips the result vertically if required. 
		/// The function is used by cvShowImage.
		/// </summary>
		/// <param name="src">Source image.</param>
		/// <param name="dst">Destination image. Must be single-channel or 3-channel 8-bit image.</param>
		/// <param name="flags">The operation flags:
		/// CV_CVTIMG_FLIP - flip the image vertically 
		/// CV_CVTIMG_SWAP_RB - swap red and blue channels. 
		/// In OpenCV color images have BGR channel order, 
		/// however on some systems the order needs to be reversed before 
		/// displaying the image (cvShowImage does this automatically).</param>
		public static void CvConvertImage(ref IplImage src, ref IplImage dst, int flags)
		{
			cvConvertImage(ref src, ref dst, flags);
		}
		public static void CvConvertImage(ref CvMat src, ref CvMat dst, int flags)
		{
			cvConvertImage(ref src, ref dst, flags);
		}
		public static void CvConvertImage(ref CvSeq src, ref CvSeq dst, int flags)
		{
			cvConvertImage(ref src, ref dst, flags);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvConvertImage(ref IplImage src, ref IplImage dst, int flags);
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvConvertImage(ref CvMat src, ref CvMat dst, int flags);
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvConvertImage(ref CvSeq src, ref CvSeq dst, int flags);

		/// <summary>
		/// cvNamedWindow 
		/// Creates window 
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public static int CvNamedWindow(string name, int flags)
		{
				return cvNamedWindow(name, flags);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern int cvNamedWindow([MarshalAs(UnmanagedType.LPStr)] String name, int flags);

		/// <summary>
		/// cvDestroyWindow 
		/// Destroys a window 
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public static void CvDestroyWindow(string name)
		{
				cvDestroyWindow(name);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvDestroyWindow([MarshalAs(UnmanagedType.LPStr)] String name);

		/// <summary>
		/// cvDestroyAllWindows 
		/// Destroys all the HighGUI windows 
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public static void CvDestroyAllWindows()
		{
				cvDestroyAllWindows();
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvDestroyAllWindows();

		/// <summary>
		/// cvMoveWindow 
		/// Sets window position 
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public static void CvMoveWindow(string name, int x, int y)
		{
				cvMoveWindow(name, x, y);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvMoveWindow([MarshalAs(UnmanagedType.LPStr)] String name, int x, int y);

		/// <summary>
		/// cvGetWindowHandle 
		/// Gets window handle by name 
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public static IntPtr CvGetWindowHandle(string name)
		{
				return cvGetWindowHandle(name);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern IntPtr cvGetWindowHandle([MarshalAs(UnmanagedType.LPStr)] String name);

		/// <summary>
		/// cvGetWindowName 
		/// Gets window name by handle 
		/// </summary>
		/// <param name="window_handle"></param>
		/// <returns></returns>
		public static string CvGetWindowName(IntPtr window_handle)
		{
				return Marshal.PtrToStringAnsi(cvGetWindowName(window_handle));
		}
		[DllImport(HIGHGUI_LIBRARY, CharSet = CharSet.Ansi)]
		private static extern IntPtr cvGetWindowName(IntPtr window_handle);

		/// <summary>
		/// The function cvShowImage shows the image
		/// in the specified window. If the window was created
		/// with CV_WINDOW_AUTOSIZE flag then the image is shown
		/// with its original size, otherwise the image is scaled
		/// to fit the window.
		/// </summary>
		/// <param name="name">The name of the window.</param>
		/// <param name="image">The image to be shown.</param>
		public static void CvShowImage( string name, ref IplImage image)
		{
				cvShowImage(name, ref image);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvShowImage([MarshalAs(UnmanagedType.LPStr)] String name, ref IplImage image);

		/// <summary>
		/// The function cvShowImage shows the image
		/// in the specified window. If the window was created
		/// with CV_WINDOW_AUTOSIZE flag then the image is shown
		/// with its original size, otherwise the image is scaled
		/// to fit the window.
		/// </summary>
		/// <param name="name">The name of the window.</param>
		/// <param name="image">image pointer as returned by some special functions</param>
		public static void CvShowImageFast( string name, IntPtr image)
		{
				cvShowImage(name, image);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvShowImage([MarshalAs(UnmanagedType.LPStr)] String name, IntPtr image);

		/// <summary>
		/// Creates the trackbar and attaches it to the specified window
		/// </summary>
		/// <param name="trackbar_name">The trackbar name.</param>
		/// <param name="window_name">The window name.</param>
		/// <param name="value">Trackbar value (output)</param>
		/// <param name="count">Count.</param>
		/// <param name="on_change">The on_change callback (delegate)</param>
		/// <returns>not documented</returns>
		public static int CvCreateTrackbar(string trackbar_name, string window_name, ref int value, int count, OnTrackbarChangeCallback on_change)
		{
				return cvCreateTrackbar(trackbar_name, window_name, ref value, count, on_change);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern int cvCreateTrackbar([MarshalAs(UnmanagedType.LPStr)] String trackbar_name, [MarshalAs(UnmanagedType.LPStr)] String window_name, ref int value, int count, [MarshalAs(UnmanagedType.FunctionPtr)] OnTrackbarChangeCallback on_change);
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void OnTrackbarChangeCallback(int value);

		/// <summary>
		/// Retrieves trackbar position
		/// </summary>
		/// <param name="trackbar_name">The trackbar name.</param>
		/// <param name="window_name">The window name.</param>
		/// <returns>trackbar position</returns>
		public static int CvGetTrackbarPos(string trackbar_name, string window_name)
		{
				return cvGetTrackbarPos(trackbar_name, window_name);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern int cvGetTrackbarPos([MarshalAs(UnmanagedType.LPStr)] String trackbar_name, [MarshalAs(UnmanagedType.LPStr)] String window_name);

		/// <summary>
		/// Sets trackbar position
		/// </summary>
		/// <param name="trackbar_name">The trackbar name.</param>
		/// <param name="window_name">The window name.</param>
		/// <param name="pos">The trackbar pos.</param>
		public static void CvSetTrackbarPos(string trackbar_name, string window_name, int pos)
		{
				cvSetTrackbarPos(trackbar_name, window_name, pos);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvSetTrackbarPos([MarshalAs(UnmanagedType.LPStr)] String trackbar_name, [MarshalAs(UnmanagedType.LPStr)] String window_name, int pos);

		/// <summary>
		/// The function cvSetMouseCallback sets the callback function for mouse events occuting within the specified window
		/// </summary>
		/// <param name="window_name">The window_name.</param>
		/// <param name="on_mouse">The on_mouse callback delegate.</param>
		/// <param name="param">The param.</param>
		public static void CvSetMouseCallback(string window_name, OnMouseCallback on_mouse, IntPtr param)
		{
			cvSetMouseCallback(window_name, on_mouse, param);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern void cvSetMouseCallback([MarshalAs(UnmanagedType.LPStr)] String window_name, [MarshalAs(UnmanagedType.FunctionPtr)] OnMouseCallback on_mouse, IntPtr param);
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void OnMouseCallback(int evnt, int x, int y, int flags, IntPtr param);

		/// <summary>
		/// Waits for a pressed key
		/// </summary>
		/// <param name="delay">The delay.</param>
		/// <returns></returns>
		public static int CvWaitKey(int delay)
		{
				return cvWaitKey(delay);
		}
		[DllImport(HIGHGUI_LIBRARY)]
		private static extern int cvWaitKey(int delay);
	}
}
