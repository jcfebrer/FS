//*******************************************************************
// File name: $ CvTypes.cs $
// Author:		$ Heiko Kießling, (c) iib-chemnitz.de $
// Email:			hki@hrz.tu-chemnitz.de
// 
// License:		There is no explicit license attached. The code is
//						provided 'as is'. Feel free to use the code how you like 
//						but without any warranty.
//						If you include the code in your own projects and/or
//						redistribute pls. include this header.
//
// History:		Rev. 1.0 (beta), hki - initial revision
// ToDo:			Documentation
//*******************************************************************
// Code generated by cvDocParser V1.0
//*******************************************************************


using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace openCV
{
	///* spatial and central moments */
	[StructLayout(LayoutKind.Sequential)]
	public struct CvMoments
	{
		public double m00;
		public double m10;
		public double m01;
		public double m20;
		public double m11;
		public double m02;
		public double m30;
		public double m21;
		public double m12;
		public double m03;
		/* spatial moments */
		public double mu20;
		public double mu11;
		public double mu02;
		public double mu30;
		public double mu21;
		public double mu12;
		public double mu03; 
		/* central moments */
		public double inv_sqrt_m00; /* m00 != 0 ? 1/sqrt(m00) : 0 */
	}

	/* Hu invariants */
	[StructLayout(LayoutKind.Sequential)]
	public struct CvHuMoments
	{
		public double hu1;
		public double hu2;
		public double hu3;
		public double hu4;
		public double hu5;
		public double hu6;
		public double hu7; /* Hu invariants */
	}

	// *******************
	// Connected Component
	// *******************/
	[StructLayout(LayoutKind.Sequential)]
	public struct CvConnectedComp
	{
		double area;    /* area of the connected component  */
		CvScalar value; /* average color of the connected component */
		CvRect rect;    /* ROI of the component  */
		//CvSeq*
		IntPtr contour; /* optional component boundary
	                    (the contour might have child contours corresponding to the holes)*/
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvContourInfo
	{
    int flags;
    IntPtr next;        /* next contour with the same mark value */
    IntPtr parent;      /* information about parent contour */
    IntPtr contour;     /* corresponding contour (may be 0, if rejected) */
    CvRect rect;        /* bounding rectangle */
    CvPoint origin;     /* origin point (where the contour was traced from) */
    int is_hole;        /* hole flag */
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvContourScanner
  {
		public IntPtr storage1;								/* contains fetched contours */
		public IntPtr storage2;								/* contains approximated contours
																					(!=storage1 if approx_method2 != approx_method1) */
		public IntPtr cinfo_storage;					/* contains _CvContourInfo nodes */
		public IntPtr cinfo_set;							/* set of _CvContourInfo nodes */
		public CvMemStoragePos initial_pos;		/* starting storage pos */
		public CvMemStoragePos backup_pos;		/* beginning of the latest approx. contour */
		public CvMemStoragePos backup_pos2;		/* ending of the latest approx. contour */
		public IntPtr img0;										/* image origin */
		public IntPtr img;										/* current image row */
		public int img_step;									/* image step */
		public CvSize img_size;								/* ROI size */
		public CvPoint offset;								/* ROI offset: coordinates, added to each contour point */
		public CvPoint pt;										/* current scanner position */
		public CvPoint lnbd;									/* position of the last met contour */
		public int nbd;												/* current mark val */
		public IntPtr l_cinfo;								/* information about latest approx. contour */
		public CvContourInfo cinfo_temp;			/* temporary var which is used in simple modes */
		public CvContourInfo frame_info;			/* information about frame */
		public CvSeq frame;										/* frame itself */
		public int approx_method1;						/* approx method when tracing */
		public int approx_method2;						/* final approx method */
		public int mode;											/* contour scanning mode:
																					0 - external only
																					1 - all the contours w/o any hierarchy
																					2 - connected components (i.e. two-level structure -
																					external contours and holes) */
		public int subst_flag;
		public int seq_type1;									/* type of fetched contours */
		public int header_size1;							/* hdr size of fetched contours */
		public int elem_size1;								/* elem size of fetched contours */
		public int seq_type2;									/*                                       */
		public int header_size2;							/*        the same for approx. contours  */
		public int elem_size2;								/*                                       */
		[MarshalAs(UnmanagedType.ByValArray, SizeConst=126)]
		public CvContourInfo[] cinfo_table;
		public IntPtr ptr;
  }

	// ToDo
	[StructLayout(LayoutKind.Sequential)]
	public struct CvChainPtReader
	{
	  public int          header_size;                                       
	  public IntPtr       seq;						/* CvSeq*, sequence, beign read */             
	  public IntPtr				block;					/* CvSeqBlock* current block */                    
	  public IntPtr       ptr1;						/* char* pointer to element be read next */  
	  public IntPtr       block_min;			/* char* pointer to the beginning of block */
	  public IntPtr       block_max;			/* char* pointer to the end of block */      
	  public int          delta_index;		/* = seq->first->start_index   */      
	  public IntPtr       prev_elem;			/* char* pointer to previous element */
	  public byte					code;
	  public CvPoint		  pt;
	  public IntPtr       deltas; //[8][2];
		public IntPtr				ptr;
	}

	/* Contour tree header */
	[StructLayout(LayoutKind.Sequential)]
	public struct CvContourTree
	{
		public int flags;							/* micsellaneous flags */
		public int header_size;				/* size of sequence header */
		public IntPtr h_prev;					/* previous sequence */
		public IntPtr h_next;					/* next sequence */
		public IntPtr v_prev;					/* 2nd previous sequence */
		public IntPtr v_next;					/* 2nd next sequence */
		public int total;							/* total number of elements */
		public int elem_size;					/* size of sequence element in bytes */
		public IntPtr block_max;			/* maximal bound of the last block */
		public IntPtr pt;							/* current write pointer */
		public int delta_elems;				/* how many elements allocated when the seq grows */
		public IntPtr storage;				/* where the seq is stored */
		public IntPtr free_blocks;		/* free blocks list */
		public IntPtr first;					/* pointer to the first sequence block */
		public CvPoint p1;            /* the first point of the binary tree root segment */
		public CvPoint p2;            /* the last point of the binary tree root segment */
		public IntPtr ptr;
	}

	/* Finds a sequence of convexity defects of given contour */
	[StructLayout(LayoutKind.Sequential)]
	public struct CvConvexityDefect
	{
    IntPtr start;				/* point of the contour where the defect begins */
    IntPtr end;					/* point of the contour where the defect ends */
    IntPtr depth_point; /* the farthest from the convex hull point within the defect */
    float depth;				/* distance between the farthest point and the convex hull */
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvQuadEdge2D
	{
		public int flags;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public CvSubdiv2DPoint[] pt;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public uint[] next;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvSubdiv2DPoint
	{
    public int flags;
		public uint first;
		public CvPoint2D32f pt;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvSubdiv2D
	{
		public int flags;								/* micsellaneous flags */
		public int header_size;					/* size of sequence header */
		public IntPtr h_prev;						/* previous sequence */
		public IntPtr h_next;						/* next sequence */
		public IntPtr v_prev;						/* 2nd previous sequence */
		public IntPtr v_next;						/* 2nd next sequence */
		public int total;								/* total number of elements */
		public int elem_size;						/* size of sequence element in bytes */
		public IntPtr block_max;				/* maximal bound of the last block */
		public IntPtr pt;								/* current write pointer */
		public int delta_elems;					/* how many elements allocated when the seq grows */
		public IntPtr storage;					/* where the seq is stored */
		public IntPtr free_blocks;			/* free blocks list */
		public IntPtr first;						/* pointer to the first sequence block */
		public IntPtr free_elems;
		public int active_count;
		public IntPtr edges;
		public int  quad_edges;
		public int  is_geometry_valid;
		public uint recent_edge;
		public CvPoint2D32f  topleft;
		public CvPoint2D32f  bottomright;
		public IntPtr ptr;
	}


	public enum CvSubdiv2DPointLocation
	{
    CV_PTLOC_ERROR = -2,
    CV_PTLOC_OUTSIDE_RECT = -1,
    CV_PTLOC_INSIDE = 0,
    CV_PTLOC_VERTEX = 1,
    CV_PTLOC_ON_EDGE = 2
	}

	public enum CvNextEdgeType
	{
    CV_NEXT_AROUND_ORG   = 0x00,
    CV_NEXT_AROUND_DST   = 0x22,
    CV_PREV_AROUND_ORG   = 0x11,
    CV_PREV_AROUND_DST   = 0x33,
    CV_NEXT_AROUND_LEFT  = 0x13,
    CV_NEXT_AROUND_RIGHT = 0x31,
    CV_PREV_AROUND_LEFT  = 0x20,
    CV_PREV_AROUND_RIGHT = 0x02
	}

	/* Filters used in pyramid decomposition */
	public enum CvFilter
	{
	    CV_GAUSSIAN_5x5 = 7
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvMatrix3
	{
		IntPtr m;  //float[3][3];
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvConDensation
	{
    public int MP;
    public int DP;
    public IntPtr DynamMatr;       /* Matrix of the linear Dynamics system  */
    public IntPtr State;           /* Vector of State                       */
    public int SamplesNum;         /* Number of the Samples                 */
    public IntPtr flSamples;      /* arr of the Sample Vectors             */
    public IntPtr flNewSamples;   /* temporary array of the Sample Vectors */
    public IntPtr flConfidence;    /* Confidence for each Sample            */
    public IntPtr flCumulative;    /* Cumulative confidence                 */
    public IntPtr Temp;            /* Temporary vector                      */
    public IntPtr RandomSample;    /* RandomVector to update sample set     */
    public IntPtr RandS; /* Array of structures to generate random vectors */
		public IntPtr ptr;
	}

	//*
	//standard Kalman filter (in G. Welch' and G. Bishop's notation):

	//  x(k)=A*x(k-1)+B*u(k)+w(k)  p(w)~N(0,Q)
	//  z(k)=H*x(k)+v(k),   p(v)~N(0,R)
	//*/

	[StructLayout(LayoutKind.Sequential)]
	public struct CvKalman
	{
		public int MP;                     /* number of measurement vector dimensions */
		public int DP;                     /* number of state vector dimensions */
		public int CP;                     /* number of control vector dimensions */

    /* backward compatibility fields */
		public IntPtr PosterState;         /* =state_pre->data.fl */
		public IntPtr PriorState;          /* =state_post->data.fl */
		public IntPtr DynamMatr;           /* =transition_matrix->data.fl */
		public IntPtr MeasurementMatr;     /* =measurement_matrix->data.fl */
		public IntPtr MNCovariance;        /* =measurement_noise_cov->data.fl */
		public IntPtr PNCovariance;        /* =process_noise_cov->data.fl */
		public IntPtr KalmGainMatr;        /* =gain->data.fl */
		public IntPtr PriorErrorCovariance;/* =error_cov_pre->data.fl */
		public IntPtr PosterErrorCovariance;/* =error_cov_post->data.fl */
		public IntPtr Temp1;               /* temp1->data.fl */
		public IntPtr Temp2;               /* temp2->data.fl */

		public IntPtr state_pre;           /* predicted state (x'(k)):
                                    x(k)=A*x(k-1)+B*u(k) */
		public IntPtr state_post;          /* corrected state (x(k)):
                                    x(k)=x'(k)+K(k)*(z(k)-H*x'(k)) */
		public IntPtr transition_matrix;   /* state transition matrix (A) */
		public IntPtr control_matrix;      /* control matrix (B)
                                   (it is not used if there is no control)*/
		public IntPtr measurement_matrix;  /* measurement matrix (H) */
		public IntPtr process_noise_cov;   /* process noise covariance matrix (Q) */
		public IntPtr measurement_noise_cov; /* measurement noise covariance matrix (R) */
		public IntPtr error_cov_pre;       /* priori error estimate covariance matrix (P'(k)):
                                    P'(k)=A*P(k-1)*At + Q)*/
		public IntPtr gain;                /* Kalman gain matrix (K(k)):
                                    K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)*/
		public IntPtr error_cov_post;      /* posteriori error estimate covariance matrix (P(k)):
                                    P(k)=(I-K(k)*H)*P'(k) */
		public IntPtr temp1;               /* temporary matrices */
		public IntPtr temp2;
		public IntPtr temp3;
		public IntPtr temp4;
		public IntPtr temp5;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct _rec
	{
		CvRect r;
		float weight;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvHaarFeature
	{
    public int  tilted;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst=3)]
		public _rec[] rec;
		public IntPtr ptr; 
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvHaarClassifier
	{
    public int count;
    public IntPtr haar_feature;
    public IntPtr threshold;
    public IntPtr left;
    public IntPtr right;
    public IntPtr alpha;
		public IntPtr ptr;
	}

	public struct CvHaarStageClassifier
	{
    public int  count;
    public float threshold;
    public IntPtr classifier;

    public int next;
    public int child;
    public int parent;
		public IntPtr ptr;
	}

//typedef struct CvHidHaarClassifierCascade CvHidHaarClassifierCascade;

	[StructLayout(LayoutKind.Sequential)]
	public struct CvHidHaarClassifierCascade
	{
    public int  flags;
    public int  count;
    public CvSize orig_window_size;
    public CvSize real_window_size;
    public double scale;
    public IntPtr stage_classifier;
    public IntPtr hid_cascade;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvHaarClassifierCascade
	{
    public int  flags;
    public int  count;
    public CvSize orig_window_size;
    public CvSize real_window_size;
    public double scale;
    public IntPtr stage_classifier;
    public IntPtr hid_cascade;
		public IntPtr ptr;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct CvAvgComp
	{
		public CvRect rect;
		public int neighbors;
	}

	[StructLayout(LayoutKind.Sequential)]
		public struct CvFont
		{
			public int font_face;
			public IntPtr ascii;
			public IntPtr greek;
			public IntPtr cyrillic;
			public float hscale, vscale;
			public float shear;
			public int thickness;
			public float dx;
			public int line_type;
		}


	public partial class cvlib
	{
		public const int CV_BGR2BGRA = 0;
		public const int CV_RGB2RGBA = CV_BGR2BGRA;

		public const int CV_BGRA2BGR = 1;
		public const int CV_RGBA2RGB = CV_BGRA2BGR;

		public const int CV_BGR2RGBA = 2;
		public const int CV_RGB2BGRA = CV_BGR2RGBA;

		public const int CV_RGBA2BGR = 3;
		public const int CV_BGRA2RGB = CV_RGBA2BGR;

		public const int CV_BGR2RGB = 4;
		public const int CV_RGB2BGR = CV_BGR2RGB;

		public const int CV_BGRA2RGBA = 5;
		public const int CV_RGBA2BGRA = CV_BGRA2RGBA;

		public const int CV_BGR2GRAY = 6;
		public const int CV_RGB2GRAY = 7;
		public const int CV_GRAY2BGR = 8;
		public const int CV_GRAY2RGB = CV_GRAY2BGR;
		public const int CV_GRAY2BGRA = 9;
		public const int CV_GRAY2RGBA = CV_GRAY2BGRA;
		public const int CV_BGRA2GRAY = 10;
		public const int CV_RGBA2GRAY = 11;

		public const int CV_BGR2BGR565 = 12;
		public const int CV_RGB2BGR565 = 13;
		public const int CV_BGR5652BGR = 14;
		public const int CV_BGR5652RGB = 15;
		public const int CV_BGRA2BGR565 = 16;
		public const int CV_RGBA2BGR565 = 17;
		public const int CV_BGR5652BGRA = 18;
		public const int CV_BGR5652RGBA = 19;

		public const int CV_GRAY2BGR565 = 20;
		public const int CV_BGR5652GRAY = 21;

		public const int CV_BGR2BGR555 = 22;
		public const int CV_RGB2BGR555 = 23;
		public const int CV_BGR5552BGR = 24;
		public const int CV_BGR5552RGB = 25;
		public const int CV_BGRA2BGR555 = 26;
		public const int CV_RGBA2BGR555 = 27;
		public const int CV_BGR5552BGRA = 28;
		public const int CV_BGR5552RGBA = 29;

		public const int CV_GRAY2BGR555 = 30;
		public const int CV_BGR5552GRAY = 31;
		public const int CV_BGR2XYZ = 32;
		public const int CV_RGB2XYZ = 33;
		public const int CV_XYZ2BGR = 34;
		public const int CV_XYZ2RGB = 35;

		public const int CV_BGR2YCrCb = 36;
		public const int CV_RGB2YCrCb = 37;
		public const int CV_YCrCb2BGR = 38;
		public const int CV_YCrCb2RGB = 39;

		public const int CV_BGR2HSV = 40;
		public const int CV_RGB2HSV = 41;

		public const int CV_BGR2Lab = 44;
		public const int CV_RGB2Lab = 45;

		public const int CV_BayerBG2BGR = 46;
		public const int CV_BayerGB2BGR = 47;
		public const int CV_BayerRG2BGR = 48;
		public const int CV_BayerGR2BGR = 49;

		public const int CV_BayerBG2RGB = CV_BayerRG2BGR;
		public const int CV_BayerGB2RGB = CV_BayerGR2BGR;
		public const int CV_BayerRG2RGB = CV_BayerBG2BGR;
		public const int CV_BayerGR2RGB = CV_BayerGB2BGR;

		public const int CV_BGR2Luv = 50;
		public const int CV_RGB2Luv = 51;
		public const int CV_BGR2HLS = 52;
		public const int CV_RGB2HLS = 53;

		public const int CV_HSV2BGR = 54;
		public const int CV_HSV2RGB = 55;

		public const int CV_Lab2BGR = 56;
		public const int CV_Lab2RGB = 57;
		public const int CV_Luv2BGR = 58;
		public const int CV_Luv2RGB = 59;
		public const int CV_HLS2BGR = 60;
		public const int CV_HLS2RGB = 61;
		public const int CV_COLORCVT_MAX = 100;

		public const int CV_SHAPE_RECT = 0;
		public const int CV_SHAPE_CROSS = 1;
		public const int CV_SHAPE_ELLIPSE = 2;
		public const int CV_SHAPE_CUSTOM = 100;

		public const int CV_HAAR_MAGIC_VAL = 0x42500000;
		public const string CV_TYPE_NAME_HAAR = "opencv-haar-classifier";

		/* contour retrieval mode */
		public const int CV_RETR_EXTERNAL = 0;
		public const int CV_RETR_LIST     = 1;
		public const int CV_RETR_CCOMP    = 2;
		public const int CV_RETR_TREE     = 3;

		/* contour approximation method */
		public const int CV_CHAIN_CODE               = 0;
		public const int CV_CHAIN_APPROX_NONE        = 1;
		public const int CV_CHAIN_APPROX_SIMPLE      = 2;
		public const int CV_CHAIN_APPROX_TC89_L1     = 3;
		public const int CV_CHAIN_APPROX_TC89_KCOS   = 4;
		public const int CV_LINK_RUNS = 5;

		//typedef size_t CvSubdiv2DEdge;
		public const int CV_SUBDIV2D_VIRTUAL_POINT_FLAG = (1 << 30);

		///* get the next edge with the same origin point (counterwise) */
		//#define  CV_SUBDIV2D_NEXT_EDGE( edge )  (((CvQuadEdge2D*)((edge) & ~3))->next[(edge)&3])


		/* Defines for Distance Transform */
		public const int CV_DIST_USER    = -1;  /* User defined distance */
		public const int CV_DIST_L1      = 1;   /* distance = |x1-x2| + |y1-y2| */
		public const int CV_DIST_L2      = 2;   /* the simple euclidean distance */
		public const int CV_DIST_C       = 3;   /* distance = max(|x1-x2|,|y1-y2|) */
		public const int CV_DIST_L12     = 4;   /* L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) */
		public const int CV_DIST_FAIR    = 5;   /* distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 */
		public const int CV_DIST_WELSCH  = 6;   /* distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 */
		public const int CV_DIST_HUBER = 7;   /* distance = |x|<c ? x^2/2 : c(|x|-c/2), c=1.345 */

		//typedef float*   CvVect32f;
		//typedef float*   CvMatr32f;
		//typedef double*  CvVect64d;
		//typedef double*  CvMatr64d;

		/* initializes 8-element array for fast access to 3x3 neighborhood of a pixel */
		public static void CV_INIT_3X3_DELTAS( ref int[] deltas, int step, int nch)
		{
		  deltas[0] = nch;  
			deltas[1] = -step + nch;
		  deltas[2] = -step; 
		  deltas[3] = -step - nch;
		  deltas[4] = -nch;  
		  deltas[5] = step - nch;
		  deltas[6] = step;
			deltas[7] = step + nch;
		}

		//typedef float (CV_CDECL * CvDistanceFunction)( const float* a, const float* b, void* user_param );

		//#define CV_IS_HAAR_CLASSIFIER( haar )                                                    \
		//    ((haar) != NULL &&                                                                   \
		//    (((const CvHaarClassifierCascade*)(haar))->flags & CV_MAGIC_MASK)==CV_HAAR_MAGIC_VAL)

		public const int CV_HAAR_FEATURE_MAX = 3;
	}
}
