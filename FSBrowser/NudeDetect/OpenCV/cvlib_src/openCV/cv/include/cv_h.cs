//*******************************************************************
// File name: $ Cv_h.cs $
// Author:		$ Heiko Kießling, (c) iib-chemnitz.de $
// Email:			hki@hrz.tu-chemnitz.de
// 
// License:		There is no explicit license attached. The code is
//						provided 'as is'. Feel free to use the code how you like 
//						but without any warranty.
//						If you include the code in your own projects and/or
//						redistribute pls. include this header.
//
// History:		Rev. 1.0 (beta), hki - initial revision
// ToDo:			Documentation
//*******************************************************************
// Code generated by cvDocParser V1.0
//*******************************************************************


using System;
using System.Collections.Generic;
using System.Text;

namespace openCV
{
	public struct CvPOSITObject
	{
		public int N;
		public IntPtr inv_matr;
		public IntPtr obj_vecs;
		public IntPtr img_vecs;
		public IntPtr ptr;
	}

	public partial class cvlib
	{
		/*******************
		 * Image Processing
		 *******************/
		public const int CV_BLUR_NO_SCALE = 0;
		public const int CV_BLUR = 1;
		public const int CV_GAUSSIAN = 2;
		public const int CV_MEDIAN = 3;
		public const int CV_BILATERAL = 4;
		public const int CV_INPAINT_NS = 0;
		public const int CV_INPAINT_TELEA = 1;
		public const int CV_SCHARR = -1;
		public const int CV_MAX_SOBEL_KSIZE = 7;
		public const int CV_INTER_NN = 0;
		public const int CV_INTER_LINEAR = 1;
		public const int CV_INTER_CUBIC = 2;
		public const int CV_INTER_AREA = 3;
		public const int CV_WARP_FILL_OUTLIERS = 8;
		public const int CV_WARP_INVERSE_MAP = 16;
		public const int CV_MOP_OPEN = 2;
		public const int CV_MOP_CLOSE = 3;
		public const int CV_MOP_GRADIENT = 4;
		public const int CV_MOP_TOPHAT = 5;
		public const int CV_MOP_BLACKHAT = 6;
		/* Methods for comparing two array */
		public const int CV_TM_SQDIFF = 0;
		public const int CV_TM_SQDIFF_NORMED = 1;
		public const int CV_TM_CCORR = 2;
		public const int CV_TM_CCORR_NORMED = 3;
		public const int CV_TM_CCOEFF = 4;
		public const int CV_TM_CCOEFF_NORMED = 5;
		public const int CV_LKFLOW_PYR_A_READY = 1;
		public const int CV_LKFLOW_PYR_B_READY = 2;
		public const int CV_LKFLOW_INITIAL_GUESSES = 4;

		
		/* Simplified Delaunay diagram creation */
		// aready defined for dll
		//public static IntPtr CvCreateSubdivDelaunay2D(CvRect rect, ref CvMemStorage storage)
		//{
		//  CvSubdiv2D* subdiv = cvCreateSubdiv2D(CV_SEQ_KIND_SUBDIV2D, sizeof(*subdiv),
		//                     sizeof(CvSubdiv2DPoint), sizeof(CvQuadEdge2D), storage );

		//  cvInitSubdivDelaunay2D( subdiv, rect );
		//  return subdiv;
		//}

		// already defined in dll
		//public static uint cvSubdiv2DRotateEdge(uint edge, int rotate)
		//{
		//  return (edge & ~3) + ((edge + rotate) & 3);
		//}

		public static uint cvSubdiv2DSymEdge(uint edge)
		{
			return edge ^ 2;
		}

		// ToDo
		//public static uint cvSubdiv2DGetEdge(uint edge, CvNextEdgeType type)
		//{
		//  CvQuadEdge2D* e = (CvQuadEdge2D*)(edge & ~3);
		//  edge = e->next[(edge + (int)type) & 3];
		//  return (edge & ~3) + ((edge + ((int)type >> 4)) & 3);
		//}

		// ToDo
		//public static CvSubdiv2DPoint* uintOrg(uint edge)
		//{
		//  CvQuadEdge2D* e = (CvQuadEdge2D*)(edge & ~3);
		//  return (CvSubdiv2DPoint*)e->pt[edge & 3];
		//}


		// ToDo
		//public static CvSubdiv2DPoint* uintDst(uint edge)
		//{
		//  CvQuadEdge2D* e = (CvQuadEdge2D*)(edge & ~3);
		//  return (CvSubdiv2DPoint*)e->pt[(edge + 2) & 3];
		//}


		public static double cvTriangleArea(CvPoint2D32f a, CvPoint2D32f b, CvPoint2D32f c)
		{
			return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
		}


		/****************************************************************************************\
		*                            Contour Processing and Shape Analysis                       *
		\****************************************************************************************/

		public const int CV_POLY_APPROX_DP = 0;
		public const int CV_DOMINANT_IPAN = 1;

		public static double cvContourPerimeter(IntPtr contour)
		{
			return cvArcLength(contour, CV_WHOLE_SEQ, 1);
		}

		public const int CV_CONTOURS_MATCH_I1 = 1;
		public const int CV_CONTOURS_MATCH_I2 = 2;
		public const int CV_CONTOURS_MATCH_I3 = 3;

		/* Compares two contour trees */
		public const int CV_CONTOUR_TREES_MATCH_I1 = 1;
		public const int CV_CLOCKWISE = 1;
		public const int CV_COUNTER_CLOCKWISE = 2;
		public const int CV_COMP_CORREL = 0;
		public const int CV_COMP_CHISQR = 1;
		public const int CV_COMP_INTERSECT = 2;
		public const int CV_COMP_BHATTACHARYYA = 3;
		public const int CV_VALUE = 1;
		public const int CV_ARRAY = 2;
		public const int CV_DIST_MASK_3 = 3;
		public const int CV_DIST_MASK_5 = 5;
		public const int CV_DIST_MASK_PRECISE = 0;

		/* Types of thresholding */
		public const int CV_THRESH_BINARY = 0			/* value = value threshold max_value 0 */;
		public const int CV_THRESH_BINARY_INV = 1 /* value = value threshold 0 max_value */;
		public const int CV_THRESH_TRUNC = 2			/* value = value threshold threshold value */;
		public const int CV_THRESH_TOZERO = 3			/* value = value threshold value 0 */;
		public const int CV_THRESH_TOZERO_INV = 4 /* value = value threshold 0 value */;
		public const int CV_THRESH_MASK = 7;
		public const int CV_THRESH_OTSU = 8;				/* use Otsu algorithm to choose the optimal threshold value;;
																								 combine the flag with one of the above CV_THRESH_* values */

		public const int CV_ADAPTIVE_THRESH_MEAN_C = 0;
		public const int CV_ADAPTIVE_THRESH_GAUSSIAN_C = 1;
		public const int CV_FLOODFILL_FIXED_RANGE = (1 << 16);
		public const int CV_FLOODFILL_MASK_ONLY = (1 << 17);
		public const int CV_CANNY_L2_GRADIENT = (1 << 31);
		public const int CV_HOUGH_STANDARD = 0;
		public const int CV_HOUGH_PROBABILISTIC = 1;
		public const int CV_HOUGH_MULTI_SCALE = 2;
		public const int CV_HOUGH_GRADIENT = 3;
		public const int CV_HAAR_DO_CANNY_PRUNING = 1;
		public const int CV_HAAR_SCALE_IMAGE = 2;
		public const int CV_CALIB_USE_INTRINSIC_GUESS = 1;
		public const int CV_CALIB_FIX_ASPECT_RATIO = 2;
		public const int CV_CALIB_FIX_PRINCIPAL_POINT = 4;
		public const int CV_CALIB_ZERO_TANGENT_DIST = 8;


		/****************************************************************************************\
		*                                 Epipolar Geometry                                      *
		\****************************************************************************************/

		/* Calculates fundamental matrix given a set of corresponding points */
		public const int CV_FM_7POINT = 1;
		public const int CV_FM_8POINT = 2;
		public const int CV_FM_LMEDS_ONLY = 4;
		public const int CV_FM_RANSAC_ONLY = 8;
		public const int CV_FM_LMEDS = (CV_FM_LMEDS_ONLY + CV_FM_8POINT);
		public const int CV_FM_RANSAC = (CV_FM_RANSAC_ONLY + CV_FM_8POINT);
	}
}

